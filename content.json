{"meta":{"title":"永远在路上 生命不息 学习不止","subtitle":"请道上大佬，多多指教","description":null,"author":"YuanFeng","url":"http://www.baidu.com","root":"/"},"pages":[{"title":"achives","date":"2019-03-10T00:54:40.000Z","updated":"2019-05-01T15:31:29.938Z","comments":true,"path":"achives/index.html","permalink":"http://www.baidu.com/achives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-05-01T21:24:47.000Z","updated":"2019-05-01T15:06:01.430Z","comments":true,"path":"categories/index.html","permalink":"http://www.baidu.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-01T21:24:27.000Z","updated":"2019-05-01T15:04:59.023Z","comments":true,"path":"tags/index.html","permalink":"http://www.baidu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LVS","slug":"LVS","date":"2019-04-18T15:22:43.000Z","updated":"2019-05-05T07:30:06.599Z","comments":true,"path":"2019/04/18/LVS/","link":"","permalink":"http://www.baidu.com/2019/04/18/LVS/","excerpt":"","text":"LVSLVS(linux virtual server)即linux虚拟服务器，是一个虚拟的服务器集群系统。 使用集群技术和Linux操作系统实现一个高性能,高可用的服务器,很好的可伸缩性(scalability),很好的可靠性(reliability),很好的可管理性(manageability). contos7: grep -i ipvs /boot/config-3.10.0-693.e17.x86_64 grep -i ipvs -C 10 /boot/config-3.10.0-693.e17.x86_64 yum install ipvsadm rpm -ql ipvsadm curl命令 lvs服务器:需要两块网卡 启用Ipforward： echo net.ipv4.ip_forward=1 &gt;&gt; /etc/sysctl.conf sysctl -p sysctl -a | grep ip_forward iptables -vnl client：需要桥接 RS1：设置网关 yum install httpd echo RS1 &gt; /var/www/html/index.html RS2；设置网关 yum install httpd echo RS2 &gt; /var/www/html/index.html LVS： 定义ipvs规则:NAt模式 yum install ipvsadm ipvsadm -A -t 172.20.0.200:80 -s rr ipvsadm -Ln ipvsadm -a -t 172.20.0.200:80 -r 192.168.80.17 -m ipvsadm -a -t 172.20.0.200:80 -r 192.168.80.27 -m ipvsadm -Ln 并发4百万 apache 1万 集群Cluster概念 系统扩展方式： scale up: 向上扩展，增强 scale out: 向外扩展，增加设备，调度分配问题， cluster Cluster: 集群，未解决某个特定问题将多台计算机组合起来形成的单个系统 Linux Cluster类型： LB：load blancing, 负载均衡 HA：high availiablity, 高可用， spof(single point of failure) MTBF: Mean Time Between Failure 平均无故障时间 MTTR: Mean Time To REStoration (repair) 平均恢复前时间（故障时间） A=MTBF/(MTBF+MTTR) (0,1): 99%,99.5%, 99.9%, 99.99%, 99.999% HPC: high-performance computing . 高性能 www.top500.org 分布式系统：分布式存储： 云盘 分布式计算： hadoop, spark Cluster分类 LB Cluster的实现 硬件：F5 big-ip citrix netscaler A10 A10 软件:lvs: linux virtual server nginx: 支持七层调度 haproxy: 支持七层调度 ats: apache trafficserver perlbal: perl编写 pound 基于工作的协议层划分： 传输层（通用）：DPORT LVS： nginx：stream haproxy: mode tcp 应用层（专用）：针对特定协议，自定义的请求模型分类 proxy server： http:nginx, httpdm haproxy(mode http),... fastcgi: nginx, httpd, ... mysql: mysql-proxy,... 会话保持：负载均衡 （1）session sticky: 同一用户调度固定服务器 source ip: lvs sh算法（对某一特定服务而言） cookie （2）session replication: 每台服务器拥有全部session session multicast cluster （3）session server: 专门的session服务器 memcached， redis HA集群实现方案 keepalived: vrrp协议 ais：应用接口规范heartbeat cman + rgmanager(RHCS) coresync_pacemaker LVS介绍LVS介绍 LVS: linux virtual server, 负载调度器，集成内核 官网：http://www.linuxvirtualserver.org/ VS：virtual server，负责调度 RS：real server,负责真正提供服务 L4：四层路由器或交换机 工作原理：vs根据请求报文的目标ip和目标协议及端口将其调度转发至某RS，根据调度算法来挑选RS iptables/netfilter: iptables:用户空间的管理工具 netfilter:内核空间上的框架 流入：PREROUTING–&gt;INPUT 流出：OUTPUT–&gt; POSTROUTING 转发：PREROUTING–&gt;FORWARD–&gt;POSTROUTING DNAT：目标地址转换；PREROUTING LVS概念 lvs集群类型中的术语： VS：virtual server, director server(DS) dispatcher(调度器)，load balancer RS:real server(lvs), upstream server(nginx) backend server(haproxy) CIP:client ip VIP:virtual serve ip VS外网的ip DIP:director ip VS内网Ip RIP:real server ip 访问流程：CIPVIP==DIPRIP LVS集群的类型 lvs: ipvsadm/ipvs ipvsadm: 用户空间的命令行工具，规则管理器 ipvs: 工作于内核空间netfilter的INPUT钩子上的框架 lvs集群的类型： lvs-nat: 修改请求报文的目标IP，多目标IP的DNAT lvs-dr: 操纵封装新的MAC地址 lvs-tun: 在原请求IP报文之外新加一个IP首部 lvs-fullnat: 修改请求报文的源和目标IP lvs-nat模式 lvs-nat: 本质是多目标IP的DNAT，通过将请求报文中的目标地址和目标端口修改为某挑出的RS的RIP和PORT实现转发 (1)RIP和DIP应在同一个IP网络，且应使用私网地址，RS的网关要指向DIP (2)请求报文和响应报文都必须经由Director转发，Director易于成为系统瓶颈 (3)支持端口映射，可修改请求报文的目标PORT (4)VS必须是linux系统，RS可以是任意OS系统 lvs-fullnat模式 lvs-fullnat: 通过同时修改请求报文的源IP地址和目标IP地址进行转发CIP--&gt;DIP VIP--&gt;RIP (1)VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此。RIP的网关一般不会指向DIP (2)RS收到的请求报文源地址是DIP，因此，只需响应给DIP；但Director还要将其发往Client (3)请求和响应报文都经由Director (4)支持端口映射 注意：此类型kernel默认不支持 LVS工作模式总结 VS/NAT VS/TUN VS/DR server any tunneling non-arp device server network private LAN/WAN LAN server number low(10~20) high(100) high(100) server gateway load balancer own router own router lvs-nat与lvs-fullnat:请求和响应报文都经由director lvs-nat:RIP的网关要指向DIP lvs-fullnat：RIP和DIP未必在同一IP网络，但要能通信 lvs-dr与lvs-tun:请求报文要经由director，但相应报文有RS直接发往client lvs-dr：通过封装新的MAC首部实现，通过MAC网络转发 lvs-tun: 通过在院IP报文外封装新IP头实现转发，支持远距离通信 ipvs scheduler ipvs scheduler: 根据其调度时是否考虑各RS当前的负载状态 两种：静态方法和动态方法 静态方法：仅根据算法本身进行调度 1. RR: roundrobin,轮询 2. WRR: weighted RR,加权轮询 3. SH: source hashing,实现session sticky，源IP地址hash；将来自同一个IP地址的请求，始终发往第一次挑中的RS，从而实现会话绑定 4. DH: destination hashing, 目标地址哈希，将发往同一个目标地址的骑牛始终发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡；如：宽带运行商 动态方法： 主要根据每个RS当前的负载状态及调度算法进行调度overhead=value较小的RS将被调度 LC: least connections 适用于长连接应用 overhead=activeconns*256+inactiveconns WLC: weighted LC,默认调度方法 overhead=(acticeconns*256+inactiveconns)/weight SED: shortest expection delay,初始连接高权重优先 overhead=(activeconns+1)*256/weight NQ: never queue, 第一轮均匀分配，后续sed LBLC: locality-based LC，动态的DH算法，使用场景：根据负载状态实现正向代理 LBLCR: LBLC with replication, 带复制功能的LBLC，解决LBLC负载不均衡问题，从负载重的复制到负载轻的RS ipvsadm命令 ipvsadm 命令： 核心功能： 集群服务管理：增，删，改 集群服务的RS管理：增，删，改 查看 ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] [-M netmask] [–pe persistence_engine] [-b sched-flags] ipvsadm -D -t|u|f service-address 删除 ipvsadm -C 清空 ipvsadm -R 重载 ipvsadm -S [-n] 保存 ipvsadm -a|e -t|u|f service-address -r server-address [options] ipvsadm -d -t|u|f service-address -r server-address ipvsadm -L|l [options] ipvsadm -Z [-t|U|f service-address] 管理集群上的RS：增，删，改 增、改：ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m] [-w weight] 删：ipvsadm -d -t|u|f service-address -r server-address server-addres: rip[:port] 如省略port，不作端口映射 选项： lvs类型:-g: gateway, dr类型，默认 -i: ipip，tun类型 -m: masquerade, nat类型 -w weight: 权重 参考http://blog.sina.com.cn/s/blog_6786545e0102vjvq.html","categories":[{"name":"lvs","slug":"lvs","permalink":"http://www.baidu.com/categories/lvs/"}],"tags":[{"name":"lvs","slug":"lvs","permalink":"http://www.baidu.com/tags/lvs/"}],"author":"yuanfeng"},{"title":"plan","slug":"plan","date":"2019-04-05T09:36:34.000Z","updated":"2019-05-03T17:52:52.569Z","comments":true,"path":"2019/04/05/plan/","link":"","permalink":"http://www.baidu.com/2019/04/05/plan/","excerpt":"","text":"planQ:web压力测试工具 A:Apache JMeter // Web Application Stress Tool // gatling // locust autoMysql / Mongodb / RedisTomact NginxKubernetes / Dockerpython shellAnsible/ Puppet / SaltStack / FabricZabbix/ Nagios / Cacti / Grafana / Prometheus / ELK /Kafka jenkins / gitlab / Lvs / HaproxyLAMP / LNMP/ DAS/SNA/NAS/","categories":[{"name":"plan other","slug":"plan-other","permalink":"http://www.baidu.com/categories/plan-other/"}],"tags":[{"name":"plan","slug":"plan","permalink":"http://www.baidu.com/tags/plan/"}],"author":"yuanfeng"},{"title":"ansible","slug":"ansible","date":"2019-03-10T15:06:52.000Z","updated":"2019-05-05T07:25:07.423Z","comments":true,"path":"2019/03/10/ansible/","link":"","permalink":"http://www.baidu.com/2019/03/10/ansible/","excerpt":"","text":"AnsibleAnsible 基础 ANSIBLE_CONFIG 环境变量，可以定义配置文件的位置 ./ansible.cfg 存在于当前工作目录 ~/.ansible.cfg 存在于当前用户家目录 /etc/ansible/ansible.cfg 默认目录 Ansible命令主机要求：windows除外 配置语言： yaml，json只有server role:ansible 可以重复使用的 Ansible: https://github.com/ansible/ansible 从release下载安装包 需要pip安装包的依赖 log： https://www.cnblogs.com/xielisen/p/6817807.html 查看文件个数：ls -l | grep ‘^-‘ | wc -l ##################################马哥 Ansible 文件传输命令执行：应用部署，配置管理，任务流编排 企业应用场景：开发，测试，发布，生产，灰度环境（基于主机，用户，地区） vie0 修改主机ip ansible -m pingm:模块ansible 127.0.0.1 -m ping 在 /etc/ansible/hosts中配置主机清单 测试网络通讯; ansible 192.168.1.101 -m ping -k 输入口令（密码）k: 密码认证建议基于key验证 etc/ssh/sshd_config ansible all -m ping all: 代表主机清单的所有主机 ansible.cfgansible.cfg forks=5 并发执行5 ansible-doc:显示模块命令 ansible websevers –list-hosts ansible all –list-host ansible debserver -m ping -u wang -k 以wang的身份去连接 ansible debserver -m command -a ‘ls /root’ -u wang -k -b -K以wang身份连接，切换到root用户权限，默认为root -K root口令 usermod -a -G wheel wang 将wang加入到组 K的口令;sudo中：取消下面一行的注释：%wheel ALL=(ALL) NOPASSWD:ALL 基于key验证 ssh-keygen ssh-copy-id 192.168.80.101 ssh-copy-id 192.168.80.102 ....... &amp; linux中表示后台执行 ansible all -m command -a “sleep 10”休眠10s command: ansible all -a ‘ls /data’ ansible all -a ‘df -h’ ansible-doc command creates 存在不执行 ansible all -a ‘removes=/etc/fs cat /etc/fstab’ removes 不存在不执行 ansible all -a ‘creates=/etc/fs cat /etc/fstab’ chdir 切换文件夹 ansible all -a ‘chdir=/root ls’ ansible 192.168.80.101 -a ‘/data/test.sh’ 执行该主机上/data/test.sh 注： 注意规范 #！/bin/bash 创建账号： ansible all -a &apos;useradd test1&apos; 查询： ansible all -a &apos;getent passwd test1&apos; command 命令对管道，重定向,变量 特殊符号支持有问题，建议shell shell： ansible all -m shell -a &apos;echo $HOSTNAME&apos; 更改口令: ansible all -m shell -a &apos;echo magedu|passwd --stdin test1&apos; script： chmod +x test.sh ansible all -m script -a ‘/root/ansible/test.sh’在所有主机上执行test.sh ansible all -a ‘getenforce’ cp /etc/sysconfig/selinux &gt;vim selinux copy:ansible-doc -s copy ansible all -m copy -a ‘src=/root/ansible/selinux dest=/etc/selinux/config backup=yes’文件复制 ansible all -m shell -a ‘getenforce’ ansible all -m copy -a ‘src=/etc/shadow dest=/data mode=000 owner=root’ ansible all -m copy -a ‘content=”hello\\n thanks \\n “ dest=/data/f2’直接写内容生成文件 fetch：从客户端去文件到服务器端，与copy相反 ansible all -m fetch -a ‘src=/var/log/messages dest=/data’从远程主机抓取log/message,到服务器，仅限单个文件 ansible all -m shell -a ‘tar jcf log.tar.xz /var/log/*.log’ 包的加压与解压archiveunarchive file： ansible all -m file -a ‘name=/data/f3 state=touch’ 创建文件 ansible all -m file -a ‘name=/data/f3 state=absent’ 删除文件 ansible all -a ‘ls -l /data’ ansible all -m file -a ‘name=/data/dir1 state=directory’ 创建文件夹，’state=absent’ 删除 ‘src=/etc/fstab dest=/data/fstab.link state=link’ 创建软连接 ‘dest=/data/fstab.link state=absent’ 删除软连接 ‘dest=/data/* state=absent’ 删除所有文件 ‘dest=/data/ state=absent’ 删除文件夹 不能删除挂载点上的 ansible 192.168.80.101 -m hostname -a ‘name=new_name’ 修改主机名 cron： ansible all -m cron -a ‘minute=* weekday=1,3,5 job=”/usr/bin/wall FBI warning” name=warningcron’ 创建定时报警任务，写入crontab ansible all -m cron -a ‘disabled=true job=”/usr/bin/wall FBI warning” name=warningcron’ 禁用此任务，必须加name ‘job=”/usr/bin/wall FBI warning” name=warningcron state=absent’ 删除 yum/etc/yum.repos/base.repo yum仓库配置 ansible all -m yum -a ‘name=vsftpd’安装多个软件用’,’隔开 ansible all -m yun -a ‘list=instealled’ 安装过的列表 ‘name=vsftpd state=removed’卸载 ‘name=vsftpd state=absent’ ‘rpm -q vsftpd’ 查找是否卸载 安装下载好的软件；ansible all -m copy -a ‘src=/data/softname dest=/root/‘ ansible all -a ‘ls /root/‘ ansbile all -m yum -a ‘name=/root/softname’ disable_gpg_check=yes 忽略，禁用 ‘name=dstat update_cache=yes’ 更新缓存 services: ansible all -m services -a ‘name=vsftpd state=started enabled=yes’启动服务，同时设为开机启动 user: ansible all -m user -a ‘name=nginx shell=/sbin/nologin system=yes home=/var/nginx groups=root,bin uid=80 comment=”nginx service”‘ 创建账号 ansible all -m user -a ‘name=nginx state=absent remove=yes’ 删除账号，删除home目录 group: ansible all -m group -a ‘name=nginx system=yes gid=80’ ansible all -a ‘getent group nginx’ ansible -m group -a ‘name=nginx state=absent’ 删除 ansible-galaxy: ansible-galaxy install geerlingguy.nginx yml/yaml: 注意缩进，格式 --- -hosts:webserver remote_user:root tasks: -name:hello command：hostname ansible-playbook test.yaml ansible-vault:ansible-vault encrypt test.yaml 对文件进行加密，避免敏感信息泄露 需要设置加密口令,再次执行yaml时会报错， ansible-vault decrypt test.yaml 解密 ansible-vault view test.yaml 查看yaml需要输入口令 ansible-vault rekey test.yaml 修改密码 ansible-vault create test2.yaml 创建新的playbook文件 ansible-console: 交互式：ansible-console “root@all (3)[f:5]$ “ 并发数量为5也可以修改forks 10 cd 192.168.80.135 切换到135主机 hostname name=node2.magedu.com 修改主机名 playbookplaybook采用YAMl语言编写 1.# test yaml 注释2.缩进必须统一 --- - hosts:webserver remote_user:root tasks: - name:create new file #描述 file:name=/data/newfile state=touch 模块/命令 - name:create new user user: name=test2 - name: install httpd yum:name=httpd - name:copy conf copy:src=/etc/conf dest=/etc/conf - name:start service service:name=httpd state=started enables=yes ansible-playbook -C file.yml # -C 检查 ansible all -a ‘getent passwd test2’ #查看test2用户 ansible all -m shell -a ‘ss -tln | grep :80’ #查看80端口 ansible all -a ‘getent passwd test2’ –limit 192.168.80.134 ansibel-playbook file.yml –list ansibel-playbook file.yml –list-tasks - name:copy a file copy:src=files/test.py dest=/etc/test.py #files相对路径，相对于当前目录 注：文件修改后再次执行copy，不会生效 更新配置文件，执行playbook后，并不会生效 http.yml --- - hosts: webserver remote_user:root tasks: - name:install https package yum:name-httpd - name: copy conf file copy: src=files/httpd.conf dest=/etc/httpd/conf baskup=yes - name: start service service: name=httpd state=started enabled=yes 执行http.yml，修改配置文件后，执行不会重启 http.yml --- - hosts: webserver remote_user:root tasks: - name:install https package yum:name-httpd tag:inshttpd - name: copy conf file copy: src=files/httpd.conf dest=/etc/httpd/conf baskup=yes notify:restart service - name: start service service: name=httpd state=started enabled=yes tag:rshttpd handlers: - name: restart service service: name=http state=restarted 也可以同时触发两个任务 tags： 添加标签，可以单独执行标签 多个动作共用一个标签 ansible-playbook -t rshttpd httpd.yml ansible-playbook -t inshttpd,rshttpd httpd.yml setup: ansible all -m setup -a ‘filter=ansible_hostname’ ansible all -m setup -a ‘filter=address‘\\ ansible all -m setup -a ‘filter=ansible_all_ipv4_address’ app.yml --- - hosts: webserver remote_user: root tasks: - name: install packing yum: name={{ pkname }} - name: start service service: name={{ pkname }} state=started enabled=yes ansible-playbook -e ‘pkname=httpd’ app.yml pkname 不会写死，灵活定义 也可以同时装多个包，用逗号隔开 eg： --- - hosts:websever remote_user: root vars: - pkname1: httpd - pkname2: vsftpd tasks: - name:install pachage yum: name={{ pkname1 }} - name: install package yum: name={{ pkname2 }} 定义变量在playbook中， hostname.yml: --- - hosts: webserver rempte_user: root tasks: - name: set hostname hostname: name= www{{http_port}}.magedu.com hosts： [webserver:vars] nodenamw=www domainname=magedu.com 此处的变量对webserver所有主机有效 tasks: - name: set hostname hostname：name={{nodename}}{{http_port}}.{{domasinname}} 命令行优先级高于配置文件 ansible all -m setupansible all -m setup -a ‘filter=”ansbile_fqdn”‘ var.yml --- - hosts:webserver renote_use: root tasks: - name: create a file file: name=/data/{{ ansible_fqdn }}.log state=touch mode=600 owner=wang ansible-playbook -c var.yml vars.yml var1: httpdvar2: vsftpd testvars.yml --- - hosts: webserver remote_user: root vars_file: - vars.yml tasks: - name：install package yum: name={{ var1 }} - name: create file file: name= /data/{{ var2 }}.log state=touch template.yml --- - hosts: webserver remote_user: root tasks: - name: install package tum: name=nginx - name: copy template template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf - name start service service: name=nginx state=started enabled=yes ansible all -m shell -a ‘ss -ntpl’ #查看端口 nginx.conf中修改: worker_processes NaN #cpu个数的2次方 修改template.yml --- - hosts: webserver remote_user: root tasks: - name: install package tum: name=nginx - name: copy template template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf notify: start service - name start service service: name=nginx state=started enabled=yes handlers: - name: restart service service: name=nginx state=restarted ansible all -m shell -a ‘ps aux | grep nginx’ #过滤nginx进程 hosts：也可以写成如下模式 [webserver]192.168.80.134 http_port=81192.168.80.135 http_port=82 ansible-playbook -e ‘http_port=99’ testtemp.yml #修改端口 优先级：命令行&gt;playbook&gt;主机清单 ansibel all -m setup -a ‘filte=ansible_os_family’ ‘filter=”distribution“‘ testitem.yml --- - hosts: webserver remote_user: root tasks: - name: create some files file: name=/data/{{ item }} state=touch when: ansible_distribution_major_version == &quot;7&quot; with_items: - file1 - file2 - file3 - name: install spme package yum: name={{ item }} with_items: - htop - sl - hping3 create_group.yml --- - hosts: all remote_user: root tasks: - name: create some groups group: name={{ item }} when: ansible_distribution_major_version == &quot;7&quot; with_items: - g1 - g2 - g3 创建用户，并加入到组 --- - hosts: all remote_user: root tasks: - name: create some groups group: name={{ item }} when: ansible_distribution_major_version == &quot;7&quot; with_items: - g1 - g2 - g3 - name:create some users user: name={{item.name}} group={{item.group}} with_items: - { name: &apos;user1&apos;, group: &apos;g1&apos; } - { name: &apos;user2&apos;, group: &apos;g2&apos; } - { name: &apos;user3&apos;, group: &apos;g3&apos; } for: testfor.yml --- - hosts: all remote_user: root vars: ports: - 81 - 82 - 83 tasks: - name: copy conf template: src=for1.conf.j2 dest=/data/for1.conf 创建文件：for1.conf.j2 {% for port in ports %} server{ listen {{ port }} } {% endfor %} 修改为字典模式： --- - hosts: all remote_user: root vars: ports: - listen_port:81 - listen_port:82 - listen_port:83 tasks: - name: copy conf template: src=for2.conf.j2 dest=/data/for1.conf for2.conf.j2 {% for port in ports %} server{ listen {{ port.listen_port }} } {% endfor %} --- - hosts: all remote_user: root vars: ports: - web1: port: 81 name: web1.magedu.com rootdir: /data/website1 - web2: port: 83 name: web2.magedu.com rootdir: /data/website2 - web3: port: 83 name: web3.magedu.com rootdir: /data/website3 tasks: - name: copy conf template: src=for3.conf.j2 dest=/data/for1.conf for3.conf.j22 {% for p in ports %} server{ listen {{ p.port }} servername {{ p.name }} documentroot {{ p.rootdir }} } {% endfor %} --- - hosts: all remote_user: root vars: ports: - web1: port: 81 #name: web1.magedu.com rootdir: /data/website1 - web2: port: 83 name: web2.magedu.com rootdir: /data/website2 - web3: port: 83 #name: web3.magedu.com rootdir: /data/website3 tasks: - name: copy conf template: src=for4.conf.j2 dest=/data/for4.conf for4.conf.j22 {% for p in ports %} server{ listen {{ p.port }} {% if p.name is defined %} servername {{ p.name }} {% endif %} documentroot {{ p.rootdir }} } {% endfor %} roles创建roles文件夹： mkdir roles mkdir roles/{httpd, mysql, memcache} -pv mkdir roles/nginx ansible all -m shell -a ‘rpm -q nginx’ ‘getent group nginx’ ‘userdel -f nginx’ 删除用户，组 cd nginx mkdir tasks templates cd tasks vim group.yml - name:create group group: name=nginx gid=80 vim user.yml - name: create user user: name=nginx group=nginx system=yes shell=/sbin/nologin uid=80 vim yum.yml - name: install package yum: name=nginx vim start.yml - name: start service service: name=nginx state=started enabled=yes vim restart.yml - name: restart service sservice: name=nginx state=restarted templates: nginx.conf.j2(nginx.conf重命名为此) vim temp.yml - name: copy conf template: src=nginx.conf.j2 dest=/etc/ngiunx/nginx.conf vim main.yml - include: group.yml - include: user.yml - include: yum.yml - include: temp.yml - include: start.yml 调用的剧本与roles同级 vim nginx_role.yml - hosts: all remote_usr: root roles: - role: nginx ansibel-playbook -c nginx_role.yml httpd_roles mkdir tasks vim user.yml - name: create user user: name=apache system=yes shell=/sbin/nologin vim copyfile.yml - name: copy file file: src= dest= httpd： tasks： vim user.yml - name: create user user: name=apache system=yes shell=/sbin/nologin vim copyfile.yml - name: copy file copy: src=httpd.conf dest=/data/ vim main.yml - include: user.yml - include: copyfile.yml vim httpd_role.yml - hosts: all remote_user: root roles: - role: httpd 在一个角色中，调用另一个角色 vim some_role.yml - hosts: all remote_user：root roles: - role: http - role: nginx 一个角色引用另一个角色中的任务在main.yml中添加一行 - include: roles/httpd/tasks/copyfileyml 此处需要注意路径的选择 ansible.cfg 当playbook失败的情况下，一个重试文件将会创建，后缀为retry，默认开启此功能 添加标签：some_role.yml --- - hosts: all remote_user: root roles: - { role: httpd, tags:[&apos;web&apos;, &apos;httpd&apos;] } #即属于web，也属于httpd - { role: nginx, tags:[&apos;web&apos;, &apos;nginx&apos;] } ansible-playbook -t web some_role.yml #只执行标签web some_role.yml --- - hosts: all remote_user: root roles: - { role: httpd, tags:[&apos;web&apos;, &apos;httpd&apos;] } #即属于web，也属于httpd - { role: nginx, tags:[&apos;web&apos;, &apos;nginx&apos;] , when: ansible_distribution_major_version == &apos;7&apos;} # 当版本为7的时候执行 mkdir appcd appmkdir tasks templates vars handlers files task: vim group.yml - name: create group group: name=app system=yes gid=123 vim user.yml - name: create user user: name=app group=app system=yes shell=/sbin/nologin uid=1223 vim yum.yml - name: isntall package yum: name=httpd vim templ.yml - name: copy conf template: src=httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf notify: restart service vars:main.yml username:app groupname: app handlers:vim main.yml - name: restart service service: name=httpd state=restarted tasks: vim start.yml - name: start service service: name=httpd state=started enabled=yes vim copyfile.yml - name: copy config copy: src=vhosts.conf dest=/etc/httpd/conf.d/ owner=app vim main.yml - include: group.yml - include: user.yml - include: yum.yml - include: templ.yml - include: copyfile.yml - include: start.yml files:touch vhosts.conf app_role.yml - hosts: all remote_user: root roles: - app memcached: yum install memcached cat /etc/sysconfig/memcached cp /etc/sysconfig/memcached templates/memcached.j2修改：CACHESIZE=”NaN“ vim tasks/yum.yml - name: install package yum: name=memcached vim taska/start.yml - name: start service service: name=memcached state=started enabled=yes vim /tasks/templ.yml - name: copy conf templates: src=memcached.j2 dest=/etc/sysconfig/memcached vim tasks/main.yml - include: yum.yml - include: templ.yml - include: start.yml vim memcached_role.yml - hosts: all remote_user: root roles: - memcached ansible-playbook -C memecached_role.yml ansible-playbook memcached_role.yml","categories":[{"name":"ansible","slug":"ansible","permalink":"http://www.baidu.com/categories/ansible/"}],"tags":[{"name":"ansible","slug":"ansible","permalink":"http://www.baidu.com/tags/ansible/"}],"author":"yuanfeng"}]}