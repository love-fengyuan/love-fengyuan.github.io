<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>永远在路上 生命不息 学习不止</title>
  
  <subtitle>请道上大佬，多多指教</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.baidu.com/"/>
  <updated>2019-05-21T00:27:52.998Z</updated>
  <id>http://www.baidu.com/</id>
  
  <author>
    <name>YuanFeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://www.baidu.com/2019/05/21/zabbix/"/>
    <id>http://www.baidu.com/2019/05/21/zabbix/</id>
    <published>2019-05-21T00:27:52.998Z</published>
    <updated>2019-05-21T00:27:52.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h1><h2 id="zabbix介绍"><a href="#zabbix介绍" class="headerlink" title="zabbix介绍"></a>zabbix介绍</h2><p>zabbix安装组件：</p><ul><li>zabbix server</li><li></li><li>zabbix database</li><li>zabbix web</li><li>zabbix agent</li><li>zabbix proxy：<br>  可以代替 Zabbix server采集性能和可用性数据。Zabbix proxy在Zabbix的部署是可选部分；但是proxy的部署可以很好的分担单个Zabbix server的负载</li><li>数据流</li></ul><p>定义</p><p>主机（host）</p><ul><li>你想要监控的联网设备，有IP/DNS。</li></ul><p>主机组（host group)</p><ul><li>主机的逻辑组；可能包含主机和模板。一个主机组里的主机和模板之间并没有任何直接的关联。通常在给不同用户组的主机分配权限时候使用主机组。</li></ul><p>监控项（item）</p><ul><li>你想要从主机接收的特定数据，一个度量（metrics）/指标数据。</li></ul><p>值预处理（value preprocessing）</p><ul><li>存入数据库之前，转化/预处理接收到的指标数据</li></ul><p>触发器（trigger）</p><ul><li>触发器是一个逻辑表达式，用来定义问题阈值和“评估”监控项接收到的数据</li></ul><p>当接收到的数据高于阈值时，触发器从“OK”变成“Problem”状态。当接收到的数据低于阈值时，触发器保留/返回“OK”的状态。</p><p>事件（event）</p><ul><li>发生的需要注意的事件，例如触发器状态改变、自动发现/监控代理自动注册</li></ul><p>事件标签（event tag）</p><ul><li>提前设置的事件标记，可以用于事件关联，权限细化设置等。</li></ul><p>事件关联（event correlation）</p><ul><li>自动灵活的、精确的关联问题和解决方案</li></ul><p>比如说，你可以定义触发器A告警的异常可以由触发器B解决，触发器B可能采用完全不同的数据采集方式。</p><p>异常（problems）</p><ul><li>处在“异常”状态的触发器</li></ul><p>异常状态更新（problem update）</p><ul><li>Zabbix提供的异常管理选项，例如添加评论、确认异常、改变严重级别或者手动关闭等。</li></ul><p>动作（action）</p><ul><li>预先定义的应对事件的动作</li></ul><p>一个动作由操作(例如发出通知)和条件(什么时间进行操作)组成</p><p>升级（escalation）</p><ul><li>用户自定义的一个在动作（action）内执行操作的场景; 发送通知/执行远程命令的序列。</li></ul><p>媒介（media）</p><ul><li>发送告警通知的方式、途径</li></ul><p>告警通知（notification）</p><ul><li>通过预先设定好的媒介途径发送事件信息给用户。</li></ul><p>远程命令（remote command）</p><ul><li>预定义好的，满足特定条件的情况下，可以在被监控主机上自动执行的命令。</li></ul><p>模版（template）</p><ul><li>被应用到一个或多个主机上的一整套实体组合（如监控项，触发器，图形，聚合图形，应用，LLD，Web场景等）。</li></ul><p>模版的应用使得主机上的监控任务部署快捷方便；也可以使监控任务的批量修改更加简单。模版是直接关联到每台单独的主机上。</p><p>应用（application）</p><ul><li>监控项的逻辑分组</li></ul><p>Web场景（web scenario）</p><ul><li>检查网站可浏览性的一个或多个HTTP请求</li></ul><p>前端（frontend)</p><ul><li>Zabbix提供的web界面</li></ul><p>仪表板（dashboard）</p><ul><li>自定义的web前端模块中，用于重要的概要和可视化信息展示的单元， 我们称之为组件（widget）。</li></ul><p>组件（widget）</p><ul><li>Dashboard中用来展示某种信息和数据的可视化组件（概览、map、图表、时钟等）。</li></ul><p>Zabbix API</p><ul><li>Zabbix API允许用户使用JSON RPC协议来创建、更新和获取Zabbix对象（如主机、监控项、图表等）信息或者执行任何其他的自定义的任务</li></ul><p>Zabbix server</p><ul><li>Zabbix软件的核心进程，执行监控操作，与Zabbix proxies和Agents进行交互、触发器计算、发送告警通知；也是数据的中央存储库</li></ul><p>Zabbix agent</p><ul><li>部署在监控对象上的进程，能够主动监控本地资源和应用</li></ul><p>Zabbix proxy</p><ul><li>代替Zabbix Server采集数据，从而分担Zabbix Server负载的进程</li></ul><p>加密（encryption）</p><ul><li>使用TLS（Transport Layer Security ）协议支持Zabbix组建之间的加密通讯(server, proxy, agent, zabbix_sender 和 zabbix_get工具) 。</li></ul><p>网络自动发现（network discovery）</p><ul><li>网络设备的自动发现。</li></ul><p>低级别自动发现（low-level discovery）</p><ul><li>特定设备上低级别实体的自动发现（如文件系统、网络接口等）。</li></ul><p>低级别自动发现规则（low-level discovery rule）</p><ul><li>为自动发现设备中低级别实体设定的一系列规则。</li></ul><p>监控项原型（item prototype）</p><ul><li>有特定变量的指标，用于自动发现。. 低级别自动发现执行之后，该变量将被实际自动发现的参数替换，该指标也自动开始采集数据。</li></ul><p>触发器原型（trigger prototype）</p><ul><li>有特定参数作为变量的触发器，用于自动发现。自动发现执行后该变量将被实际自动发现的参数替换，该触发器自动开始计算数据。</li></ul><p>还有其他的一些Zabbix 实体原型也被用于自动发现中——图表原型，主机原型，主机组原型，应用原型。</p><p>agent自动注册（agent auto-registration）</p><ul><li>Zabbix agent自己自动注册为一个主机，并且开始监控的自动执行进程。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zabbix&quot;&gt;&lt;a href=&quot;#zabbix&quot; class=&quot;headerlink&quot; title=&quot;zabbix&quot;&gt;&lt;/a&gt;zabbix&lt;/h1&gt;&lt;h2 id=&quot;zabbix介绍&quot;&gt;&lt;a href=&quot;#zabbix介绍&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>zookeeper入门</title>
    <link href="http://www.baidu.com/2019/05/21/zookeeper/"/>
    <id>http://www.baidu.com/2019/05/21/zookeeper/</id>
    <published>2019-05-20T22:30:43.000Z</published>
    <updated>2019-05-21T00:27:28.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zookeeper介绍"><a href="#zookeeper介绍" class="headerlink" title="zookeeper介绍"></a>zookeeper介绍</h2><p>ZooKeeper是一种用于分布式应用程序的分布式开源协调服务。它公开了一组简单的原语，分布式应用程序可以构建这些原语，以实现更高级别的服务，以实现同步，配置维护以及组和命名。它被设计为易于编程，并使用在熟悉的文件系统目录树结构之后设计的数据模型。它在Java中运行，并且具有Java和C的绑定。</p><p>众所周知，协调服务很难做到。他们特别容易出现比赛条件和死锁等错误。ZooKeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任</p><h2 id="zookeeper-api"><a href="#zookeeper-api" class="headerlink" title="zookeeper_api"></a>zookeeper_api</h2><p>ZooKeeper的设计目标之一是提供一个非常简单的编程接口。因此，它仅支持以下操作：</p><ul><li><p>create：在树中的某个位置创建一个节点</p></li><li><p>delete：删除节点</p></li><li><p>exists：测试某个位置是否存在节点</p></li><li><p>get data：从节点读取数据</p></li><li><p>set data：将数据写入节点</p></li><li><p>get children：检索节点的子节点列表</p></li><li><p>sync：等待传播数据</p></li></ul><h2 id="zookeeper安装"><a href="#zookeeper安装" class="headerlink" title="zookeeper安装"></a>zookeeper安装</h2><p>docker安装zookeeper</p><p>docker search zookeeper</p><p>docker pull zookeeper   #拉取镜像</p><p>docker run –privileged=true -d –name zookeeper –publish 2181:2181  -d zookeeper:latest   #启动容器并添加映射</p><h2 id="zookeeper的扩容与缩容"><a href="#zookeeper的扩容与缩容" class="headerlink" title="zookeeper的扩容与缩容"></a>zookeeper的扩容与缩容</h2><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><h3 id="集群容错（奇偶数节点问题）"><a href="#集群容错（奇偶数节点问题）" class="headerlink" title="集群容错（奇偶数节点问题）"></a>集群容错（奇偶数节点问题）</h3><p>如ZooKeeper入门指南中所述，容错群集设置至少需要三台服务器，强烈建议您使用奇数个服务器。</p><p>通常三台服务器对于生产安装来说已经足够了，但为了在维护期间获得最大可靠性，您可能希望安装五台服务器。使用三台服务器时，如果对其中一台服务器执行维护，则在维护期间，您很容易在其他两台服务器上发生故障。如果你有五个正在运行，你可以拿一个进行维护，并且知道如果其他四个中的一个突然失败你仍然可以。</p><p>参考：<a href="http://blog.itpub.net/31441024/viewspace-2212546/" target="_blank" rel="noopener">http://blog.itpub.net/31441024/viewspace-2212546/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;zookeeper介绍&quot;&gt;&lt;a href=&quot;#zookeeper介绍&quot; class=&quot;headerlink&quot; title=&quot;zookeeper介绍&quot;&gt;&lt;/a&gt;zookeeper介绍&lt;/h2&gt;&lt;p&gt;ZooKeeper是一种用于分布式应用程序的分布式开源协调服务。它公
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://www.baidu.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://www.baidu.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>iptables入门</title>
    <link href="http://www.baidu.com/2019/05/18/iptables/"/>
    <id>http://www.baidu.com/2019/05/18/iptables/</id>
    <published>2019-05-17T23:10:43.000Z</published>
    <updated>2019-05-21T00:27:15.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iptables入门"><a href="#iptables入门" class="headerlink" title="iptables入门"></a>iptables入门</h2><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><h3 id="iptables常用参数"><a href="#iptables常用参数" class="headerlink" title="iptables常用参数"></a>iptables常用参数</h3><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">-P</td><td style="text-align:left">设置默认策略</td></tr><tr><td style="text-align:left">-F</td><td style="text-align:left">清空规则链</td></tr><tr><td style="text-align:left">-L</td><td style="text-align:left">查看规则链</td></tr><tr><td style="text-align:left">-A</td><td style="text-align:left">在规则链素的末尾加入新的规则</td></tr><tr><td style="text-align:left">-I num</td><td style="text-align:left">在规则链素的头部加入新的规则</td></tr><tr><td style="text-align:left">-D num</td><td style="text-align:left">删除某一条规则</td></tr><tr><td style="text-align:left">-s</td><td style="text-align:left">匹配来源地址，加”!”表示除这个IP地址外</td></tr><tr><td style="text-align:left">-d</td><td style="text-align:left">匹配目标地址</td></tr><tr><td style="text-align:left">–dport num</td><td style="text-align:left">匹配目标端口号</td></tr><tr><td style="text-align:left">–sport num</td><td style="text-align:left">匹配来源端口号</td></tr></tbody></table><h3 id="iptables进行端口转发"><a href="#iptables进行端口转发" class="headerlink" title="iptables进行端口转发"></a>iptables进行端口转发</h3><p>第一步:开启系统的转发功能</p><pre><code>vim /etc/sysctl.conf将net.ipv4.ip_forward=0修改为net.ipv4.ip_forward=1编辑后使用命令让配置马上生效sysxrl -p</code></pre><p>第二步:iptables命令</p><pre><code>iptables -t nat -A PREROUTING -p tcp --dport [端口号] -j DNAT --to-destination [目标IP]iptables -t nat -A PREROUTING -p udp --dport [端口号] -j DNAT --to-destination [目标IP]iptables -t nat -A POSTROUTING -p tcp -d [目标IP] --dport [端口号] -j SNAT --to-source [本地服务器IP]iptables -t nat -A POSTROUTING -p udp -d [目标IP] --dport [端口号] -j SNAT --to-source [本地服务器IP]</code></pre><p>第三步:重启iptables使配置生效（仅适合Centos6，7默认没有安装iptables防火墙）</p><pre><code>service iptables saveservice iptables restart</code></pre><p>多端口转发</p><pre><code>多端口转发修改方案： ( 将本地服务器的 50000~65535 转发至目标 IP 为 1.1.1.1 的 50000~65535 端口 )-A PREROUTING -p tcp -m tcp --dport 50000:65535 -j DNAT --to-destination 1.1.1.1-A PREROUTING -p udp -m udp --dport 50000:65535 -j DNAT --to-destination 1.1.1.1-A POSTROUTING -d 1.1.1.1/32 -p tcp -m tcp --dport 50000:65535 -j SNAT --to-source [本地服务器IP]-A POSTROUTING -d 1.1.1.1/32 -p udp -m udp --dport 50000:65535 -j SNAT --to-source [本地服务器IP]不同端口号修改方案（使用本地服务器的60000端口来转发目标ip为1.1.1.1的50000端口）-A PREROUTING -p tcp -m tcp --dport 60000 -j DNAT --to-destination 1.1.1.1:50000-A PREROUTING -p udp -m udp --dport 60000 -j DNAT --to-destination 1.1.1.1:50000-A POSTROUTING -d 1.1.1.1/32 -p tcp -m tcp --dport 50000 -j SNAT --to-source [本地服务器IP]-A POSTROUTING -d 1.1.1.1/32 -p udp -m udp --dport 50000 -j SNAT --to-source [本地服务器IP]</code></pre><h3 id="主机内部端口重定向"><a href="#主机内部端口重定向" class="headerlink" title="主机内部端口重定向"></a>主机内部端口重定向</h3><p>有时可能需要将访问主机的7979端口映射到8080端口，也可以iptables重定向完成</p><pre><code>iptables -t nat -A PREROUTING -p tcp --dport 7979 -j REDIRECT --to-ports 8080</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ccuc/p/7497440.html" target="_blank" rel="noopener">https://www.cnblogs.com/ccuc/p/7497440.html</a><br><a href="https://blog.csdn.net/e_wsq/article/details/79933232" target="_blank" rel="noopener">https://blog.csdn.net/e_wsq/article/details/79933232</a></p><p><a href="https://www.cnblogs.com/itxiongwei/p/5871075.html" target="_blank" rel="noopener">https://www.cnblogs.com/itxiongwei/p/5871075.html</a><br><a href="https://blog.51cto.com/13677371/2094355（命令）" target="_blank" rel="noopener">https://blog.51cto.com/13677371/2094355（命令）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iptables入门&quot;&gt;&lt;a href=&quot;#iptables入门&quot; class=&quot;headerlink&quot; title=&quot;iptables入门&quot;&gt;&lt;/a&gt;iptables入门&lt;/h2&gt;&lt;h2 id=&quot;iptables&quot;&gt;&lt;a href=&quot;#iptables&quot; cla
      
    
    </summary>
    
      <category term="iptables" scheme="http://www.baidu.com/categories/iptables/"/>
    
    
      <category term="iptables" scheme="http://www.baidu.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>git服务器搭建</title>
    <link href="http://www.baidu.com/2019/05/06/git_server/"/>
    <id>http://www.baidu.com/2019/05/06/git_server/</id>
    <published>2019-05-05T21:42:35.000Z</published>
    <updated>2019-05-05T13:44:03.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git服务器搭建"><a href="#Git服务器搭建" class="headerlink" title="Git服务器搭建"></a>Git服务器搭建</h2><p>github是免费托管代码开源的远程仓库。若不想公开代码，又不想付费，就只能创建自己的git服务器作为仓库使用。使用一台运行的linux的计算机，通过apt命令行就可以完成安装。</p><h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h3><pre><code>安装git:    sudo apt-get install git创建一个git用户组和用户，用来运行git：    groupadd git    useradd git -g git</code></pre><h3 id="2-创建证书登录"><a href="#2-创建证书登录" class="headerlink" title="2.创建证书登录"></a>2.创建证书登录</h3><p>收集需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。如果没有该文件，创建它：</p><pre><code>$ cd /home/git/$ mkdir .ssh$ chmod 755 .ssh$ touch .ssh/authorized_keys$ chmod 644 .ssh/authorized_keys</code></pre><h3 id="3-初始化仓库"><a href="#3-初始化仓库" class="headerlink" title="3.初始化仓库"></a>3.初始化仓库</h3><p>选定一个目录作为仓库，假定是/home/gitrepo/allen.git,在/home/gitrepo目录下输入命令：</p><pre><code>$ cd /home$ mkdir gitrepo$ chown git:git gitrepo/$ cd gitrepo$ git init --bare allen.gitInitialized empty Git repository in /home/gitrepo/allen.git/</code></pre><p>以上命令创建一个裸仓库，裸仓库没有工作区。因为服务器上的git是为了共享，不让用户直接登录到服务器上去修改工作区，并且服务器上的git仓库通常都以’.git’结尾，把owner改为git：</p><pre><code>$ sudo chown -R git:git allen.git</code></pre><h4 id="禁止shell登录"><a href="#禁止shell登录" class="headerlink" title="禁止shell登录"></a>禁止shell登录</h4><p>出于安全考虑，前面创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。</p><pre><code>找到如下一行：    git:x:1001:1001:,,,:/home/git:/bin/bash改为：    git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</code></pre><p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p><h3 id="4-克隆仓库"><a href="#4-克隆仓库" class="headerlink" title="4.克隆仓库"></a>4.克隆仓库</h3><pre><code>$ git clone git@192.168.45.4:/home/gitrepo/allen.git    Cloning into &apos;allen&apos;...    warning: You appear to have cloned an empty repository.    Checking connectivity... done.</code></pre><p>192.168.45.4为git所在服务器的ip，将其修改为自己的git服务器的ip即可。</p><h2 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a>管理公钥</h2><p>Gitosis</p><h2 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h2><p>Gitolite</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git服务器搭建&quot;&gt;&lt;a href=&quot;#Git服务器搭建&quot; class=&quot;headerlink&quot; title=&quot;Git服务器搭建&quot;&gt;&lt;/a&gt;Git服务器搭建&lt;/h2&gt;&lt;p&gt;github是免费托管代码开源的远程仓库。若不想公开代码，又不想付费，就只能创建自己的git
      
    
    </summary>
    
      <category term="git" scheme="http://www.baidu.com/categories/git/"/>
    
    
      <category term="git" scheme="http://www.baidu.com/tags/git/"/>
    
      <category term="server" scheme="http://www.baidu.com/tags/server/"/>
    
  </entry>
  
  <entry>
    <title>Redis介绍与基本使用</title>
    <link href="http://www.baidu.com/2019/05/06/redis/"/>
    <id>http://www.baidu.com/2019/05/06/redis/</id>
    <published>2019-05-05T21:05:14.000Z</published>
    <updated>2019-05-05T13:31:52.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Redis-介绍"><a href="#1-Redis-介绍" class="headerlink" title="1.Redis 介绍"></a>1.Redis 介绍</h2><h4 id="实现缓存的方式，有多种，本地内存缓存，数据库缓存，文件系统缓存。这里介绍使用Redis数据库进行缓存。"><a href="#实现缓存的方式，有多种，本地内存缓存，数据库缓存，文件系统缓存。这里介绍使用Redis数据库进行缓存。" class="headerlink" title="实现缓存的方式，有多种，本地内存缓存，数据库缓存，文件系统缓存。这里介绍使用Redis数据库进行缓存。"></a>实现缓存的方式，有多种，本地内存缓存，数据库缓存，文件系统缓存。这里介绍使用Redis数据库进行缓存。</h4><p>Redis是什么？</p><p>​      REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>​      Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>​      它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>Redis 简介</p><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据(memcache)，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h2 id="2-Redis-优势"><a href="#2-Redis-优势" class="headerlink" title="2.Redis 优势"></a>2.Redis 优势</h2><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><h2 id="3-安装Redis"><a href="#3-安装Redis" class="headerlink" title="3.安装Redis"></a>3.安装Redis</h2><p> wget <a href="http://download.redis.io/releases/redis-3.2.6.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.2.6.tar.gz</a></p><p>解压：</p><p>tar -zxvf redis-3.2.6.tar.gz</p><p>cd redis-3.2.6</p><p>编译：</p><p>cd redis-3.2.6  #进入目录<br>make   #编译</p><p>设置redis</p><p>mkdir /usr/local/redis #创建redis操作目录<br>cp src/redis-server src/redis-cli /usr/local/redis/bin/  #复制redis服务和命令<br>cp redis.conf /usr/local/redis/conf   #复制redis配置文件<br>cd /usr/local/redis<br>./bin/redis-server     conf/redis.conf    &amp;    #后台启动redis</p><p><strong>创建快捷键</strong></p><p>vim  ~/.bashrc<br>alias redis=’/usr/local/redis/bin/redis-cli’  #添加快捷键<br>source ~/.bashrc   #使生效</p><p>redis远程连接</p><p><strong>redis-cli  -h  172.16.245.xxx  -p 6379</strong> </p><p>redis 172.16.245.179:6379&gt; </p><p>安装验证成功！</p><h2 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4.配置文件"></a>4.配置文件</h2><p>redis.conf 配置项说明如下：</p><ol><li>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</li></ol><p>​    <strong>daemonize no</strong></p><ol start="2"><li>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</li></ol><p>​    <strong>pidfile /var/run/redis.pid</strong></p><ol start="3"><li>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</li></ol><p>​    <strong>port 6379</strong></p><ol start="4"><li>绑定的主机地址</li></ol><p>​    <strong>bind 127.0.0.1</strong></p><ol start="5"><li>当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</li></ol><p>​    <strong>timeout 300</strong></p><ol start="6"><li>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</li></ol><p>​    <strong>loglevel verbose</strong></p><ol start="7"><li>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</li></ol><p>​    <strong>logfile stdout</strong></p><ol start="8"><li>设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id</dbid></li></ol><p>​    <strong>databases 16</strong></p><ol start="9"><li>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</li></ol><p>​    <strong>save <seconds> <changes></changes></seconds></strong></p><p>​    Redis默认配置文件中提供了三个条件：</p><p>​    <strong>save 900 1</strong></p><p><strong>    save 300 10</strong></p><p><strong>    save 60 10000</strong></p><p>​    分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</p><ol start="10"><li>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</li></ol><p>​    <strong>rdbcompression yes</strong></p><ol start="11"><li>指定本地数据库文件名，默认值为dump.rdb</li></ol><p>​    <strong>dbfilename dump.rdb</strong></p><ol start="12"><li>指定本地数据库存放目录</li></ol><p>​    <strong>dir ./</strong></p><ol start="13"><li>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</li></ol><p>​    <strong>slaveof <masterip> <masterport></masterport></masterip></strong></p><ol start="14"><li>当master服务设置了密码保护时，slav服务连接master的密码</li></ol><p>​    <strong>masterauth <master-password></master-password></strong></p><ol start="15"><li>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭</password></li></ol><p>​    <strong>requirepass foobared</strong></p><ol start="16"><li>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</li></ol><p>​    <strong>maxclients 128</strong></p><ol start="17"><li>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</li></ol><p>​    <strong>maxmemory <bytes></bytes></strong></p><ol start="18"><li>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</li></ol><p>​    <strong>appendonly no</strong></p><ol start="19"><li>指定更新日志文件名，默认为appendonly.aof</li></ol><p>​     <strong>appendfilename appendonly.aof</strong></p><ol start="20"><li>指定更新日志条件，共有3个可选值：<br>​    <strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<br>​    <strong>always</strong>：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>​    <strong>everysec</strong>：表示每秒同步一次（折衷，默认值）</li></ol><p>​    <strong>appendfsync everysec</strong></p><ol start="21"><li>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</li></ol><p>​     <strong>vm-enabled no</strong></p><ol start="22"><li>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</li></ol><p>​     <strong>vm-swap-file /tmp/redis.swap</strong></p><ol start="23"><li>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</li></ol><p>​     <strong>vm-max-memory 0</strong></p><ol start="24"><li>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</li></ol><p>​     <strong>vm-page-size 32</strong></p><ol start="25"><li>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</li></ol><p>​     <strong>vm-pages 134217728</strong></p><ol start="26"><li>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</li></ol><p>​     <strong>vm-max-threads 4</strong></p><ol start="27"><li>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</li></ol><p>​    <strong>glueoutputbuf yes</strong></p><ol start="28"><li>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</li></ol><p>​    <strong>hash-max-zipmap-entries 64</strong></p><p><strong>    hash-max-zipmap-value 512</strong></p><ol start="29"><li>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</li></ol><p>​    <strong>activerehashing yes</strong></p><ol start="30"><li>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</li></ol><p>​    <strong>include /path/to/local.conf</strong></p><p>查看配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET *</span><br></pre></td></tr></table></figure><h2 id="5-Redis数据类型"><a href="#5-Redis数据类型" class="headerlink" title="5.Redis数据类型"></a>5.Redis数据类型</h2><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>​     string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p><p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p><p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET name &quot;1000phone&quot;</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; GET name</span><br><span class="line">&quot;1000phone&quot;</span><br></pre></td></tr></table></figure><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">redis&gt; HGET myhash field1</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">redis&gt; HGET myhash field2</span><br><span class="line">&quot;World&quot;</span><br></pre></td></tr></table></figure><p>redis 172.16.245.179:6379&gt; hgetall myhash<br>1) “fd1”<br>2) “value1”<br>3) “fd2”<br>4) “value2”<br>5) “fd3”<br>6) “value2”</p><table><thead><tr><th>fd1</th><th>fd2</th><th>fd3</th></tr></thead><tbody><tr><td>value1</td><td>value2</td><td>value3</td></tr></tbody></table><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lpush name  redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush name mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush name rabitmq</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange name 0 10</span><br><span class="line">1) &quot;rabitmq&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; rpop name</span><br></pre></td></tr></table></figure><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis的Set是string类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><h3 id="sadd-命令"><a href="#sadd-命令" class="headerlink" title="sadd 命令"></a>sadd 命令</h3><p>添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key member</span><br></pre></td></tr></table></figure><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; sadd name redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd name mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd name rabitmq</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd name rabitmq</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers name</span><br><span class="line"></span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;rabitmq&quot;</span><br><span class="line">3) &quot;mongodb&quot;</span><br></pre></td></tr></table></figure><h3 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h3><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><h3 id="zadd-命令"><a href="#zadd-命令" class="headerlink" title="zadd 命令"></a>zadd 命令</h3><p>添加元素到集合，元素在集合中存在则更新对应score</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member</span><br></pre></td></tr></table></figure><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE runoob 0 1000</span><br><span class="line">1) &quot;mongodb&quot;</span><br><span class="line">2) &quot;rabitmq&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure><h2 id="6-Redis发布订阅与事务"><a href="#6-Redis发布订阅与事务" class="headerlink" title="6.Redis发布订阅与事务"></a>6.Redis发布订阅与事务</h2><h3 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h3><p>​Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p>​下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/05/06/redis/redis_dingyue.png" alt="redis订阅" title>                </div>                <div class="image-caption">redis订阅</div>            </figure><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/05/06/redis/redis_fabu.png" alt="redis发布" title>                </div>                <div class="image-caption">redis发布</div>            </figure><hr><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 <strong>redisChat</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</span><br><span class="line"></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Redis is a great caching technique&quot;</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Learn redis by runoob.com&quot;</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 订阅者的客户端会显示如下消息</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) &quot;Redis is a great caching technique&quot;</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;redisChat&quot;</span><br><span class="line">3) &quot;Learn redis by runoob.com&quot;</span><br></pre></td></tr></table></figure><h3 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h3><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><p>批量操作在发送 EXEC 命令前被放入队列缓存。<br>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。<br>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>一个事务从开始到执行会经历以下三个阶段：</p><p>开始事务。<br>命令入队。<br>执行事务。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/05/06/redis/redis_shiwu.png" alt="redis事务" title>                </div>                <div class="image-caption">redis事务</div>            </figure><h4 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h4><p>以下是一个事务的例子， 它先以 MULTI开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令：</p><p>redis 127.0.0.1:6379&gt; MULTI</p><p>OK</p><p>redis 127.0.0.1:6379&gt; SET book-name “Mastering C++ in 21 days”</p><p>QUEUED</p><p>redis 127.0.0.1:6379&gt; GET book-name</p><p>QUEUED</p><p>redis 127.0.0.1:6379&gt; SADD tag “C++” “Programming” “Mastering Series”</p><p>QUEUED</p><p>redis 127.0.0.1:6379&gt; SMEMBERS tag</p><p>QUEUED</p><p>redis 127.0.0.1:6379&gt; EXEC</p><p>1) OK</p><p>2) “Mastering C++ in 21 days”</p><p>3) (integer) 3</p><p>4) 1) “Mastering Series”</p><p>2) “C++”</p><p>3) “Programming”</p><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7000&gt; multi</span><br><span class="line"></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7000&gt; set a aaa</span><br><span class="line"></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7000&gt; set b bbb</span><br><span class="line"></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7000&gt; set c ccc</span><br><span class="line"></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7000&gt; exec</span><br><span class="line"></span><br><span class="line">1) OK</span><br><span class="line"></span><br><span class="line">2) OK</span><br><span class="line"></span><br><span class="line">3) OK</span><br></pre></td></tr></table></figure></p><p>如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。</p><h2 id="7-Python操作Redis"><a href="#7-Python操作Redis" class="headerlink" title="7.Python操作Redis"></a>7.Python操作Redis</h2><h3 id="安装redis-py"><a href="#安装redis-py" class="headerlink" title="安装redis-py"></a><strong>安装redis-py</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure><p>redis-py 的API的使用可以分类为：</p><ul><li><p>连接方式</p></li><li><p>连接池</p></li><li><p>操作</p><ul><li>String 操作</li><li>Hash 操作</li><li>List 操作</li><li>Set 操作</li><li>Sort Set 操作</li></ul></li><li><p>管道</p><p>redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line">r = redis.Redis(host=&apos;192.168.49.130&apos;, port=6379)</span><br><span class="line">r.set(&apos;foo&apos;, &apos;Bar&apos;)</span><br><span class="line">print r.get(&apos;foo&apos;)</span><br></pre></td></tr></table></figure><p><strong>创建连接池</strong>:</p><p>　　redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池。</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/05/06/redis/javascript:void(0);" alt="复制代码](https://common.cnblogs.com/images/copycode.gif)" title>                </div>                <div class="image-caption">复制代码](https://common.cnblogs.com/images/copycode.gif)</div>            </figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line"> </span><br><span class="line">pool = redis.ConnectionPool(host=&apos;192.168.49.130&apos;, port=6379)</span><br><span class="line"> </span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">#r = redis.StrictRedis(connection_pool=pool) #StrictRedis也是支持的</span><br><span class="line">r.set(&apos;foo&apos;, &apos;Bar&apos;)</span><br><span class="line">print r.get(&apos;foo&apos;)</span><br></pre></td></tr></table></figure><p>MySQL数据有两种存储引擎：</p><p>MyISAM   — 表锁</p><p>INONDB   — 表行锁   ———这种存储方式推荐使用， 支持事务</p><h2 id="8-应用场景案例"><a href="#8-应用场景案例" class="headerlink" title="8.应用场景案例"></a>8.应用场景案例</h2><h3 id="（1）页面点击数"><a href="#（1）页面点击数" class="headerlink" title="（1）页面点击数"></a>（1）页面点击数</h3><p>​     假定我们对一系列页面需要记录点击次数。例如论坛的每个帖子都要记录点击次数，而点击次数比回帖的次数的多得多。如果使用关系数据库来存储点击，可能存在大量的行级锁争用。所以，点击数的增加使用redis的INCR命令最好不过了。</p><p>​     当redis服务器启动时，可以从关系数据库读入点击数的初始值（1237这个页面被访问了34634次）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.set(&quot;visit:1237:totals&quot;,34634)</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>每当有一个页面点击，则使用INCR增加点击数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.incr(&quot;visit:1237:totals&quot;)</span><br><span class="line"></span><br><span class="line">34635</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; r.incr(&quot;visit:1237:totals&quot;)</span><br><span class="line"></span><br><span class="line">34636</span><br><span class="line"></span><br><span class="line">页面载入的时候则可直接获取这个值</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; r.get (&quot;visit:1237:totals&quot;)</span><br><span class="line"></span><br><span class="line">&apos;34636&apos;</span><br></pre></td></tr></table></figure><h3 id="（2）使用hash类型保存多样化对象，类似二维表结构"><a href="#（2）使用hash类型保存多样化对象，类似二维表结构" class="headerlink" title="（2）使用hash类型保存多样化对象，类似二维表结构"></a>（2）使用hash类型保存多样化对象，类似二维表结构</h3><p>当有大量类型文档的对象，文档的内容都不一样时，（即“表”没有固定的列），可以使用hash来表达。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.hset(&apos;users:jdoe&apos;,  &apos;name&apos;, &quot;John Doe&quot;)</span><br><span class="line"></span><br><span class="line">1L</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; r.hset(&apos;users:jdoe&apos;, &apos;email&apos;, &apos;John@test.com&apos;)</span><br><span class="line"></span><br><span class="line">1L</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; r.hset(&apos;users:jdoe&apos;,  &apos;phone&apos;, &apos;1555313940&apos;)</span><br><span class="line"></span><br><span class="line">1L</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; r.hincrby(&apos;users:jdoe&apos;, &apos;visits&apos;, 1)</span><br><span class="line"></span><br><span class="line">1L</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; r.hgetall(&apos;users:jdoe&apos;)</span><br><span class="line"></span><br><span class="line">&#123;&apos;phone&apos;: &apos;1555313940&apos;, &apos;name&apos;: &apos;John Doe&apos;, &apos;visits&apos;: &apos;1&apos;, &apos;email&apos;: &apos;John@test.com&apos;&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; r.hkeys(&apos;users:jdoe&apos;)</span><br><span class="line"></span><br><span class="line">[&apos;name&apos;, &apos;email&apos;, &apos;phone&apos;, &apos;visits&apos;]</span><br></pre></td></tr></table></figure><h3 id="（3）社交圈子数据"><a href="#（3）社交圈子数据" class="headerlink" title="（3）社交圈子数据"></a>（3）社交圈子数据</h3><p>​在社交网站中，每一个圈子(circle)都有自己的用户群。通过圈子可以找到有共同特征（比如某一体育活动、游戏、电影等爱好者）的人。当一个用户加入一个或几个圈子后，系统可以向这个用户推荐圈子中的人。<br>​我们定义这样两个圈子,并加入一些圈子成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.sadd(&apos;circle:game:lol&apos;,&apos;user:debugo&apos;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; r.sadd(&apos;circle:game:lol&apos;,&apos;user:leo&apos;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; r.sadd(&apos;circle:game:lol&apos;,&apos;user:Guo&apos;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; r.sadd(&apos;circle:soccer:InterMilan&apos;,&apos;user:Guo&apos;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; r.sadd(&apos;circle:soccer:InterMilan&apos;,&apos;user:Levis&apos;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; r.sadd(&apos;circle:soccer:InterMilan&apos;,&apos;user:leo&apos;)</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>获取一个圈子的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.smembers(&apos;circle:game:lol&apos;)</span><br><span class="line">set([&apos;user:Guo&apos;, &apos;user:debugo&apos;, &apos;user:leo&apos;])</span><br></pre></td></tr></table></figure><p>可以使用集合运算来得到几个圈子的共同成员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.sinter(&apos;circle:game:lol&apos;, &apos;circle:soccer:InterMilan&apos;)</span><br><span class="line">set([&apos;user:Guo&apos;, &apos;user:leo&apos;])</span><br><span class="line">&gt;&gt;&gt; r.sunion(&apos;circle:game:lol&apos;, &apos;circle:soccer:InterMilan&apos;)</span><br><span class="line">set([&apos;user:Levis&apos;, &apos;user:Guo&apos;, &apos;user:debugo&apos;, &apos;user:leo&apos;])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Redis-介绍&quot;&gt;&lt;a href=&quot;#1-Redis-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Redis 介绍&quot;&gt;&lt;/a&gt;1.Redis 介绍&lt;/h2&gt;&lt;h4 id=&quot;实现缓存的方式，有多种，本地内存缓存，数据库缓存，文件系统缓存。这
      
    
    </summary>
    
      <category term="redis" scheme="http://www.baidu.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.baidu.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>django</title>
    <link href="http://www.baidu.com/2019/05/06/django/"/>
    <id>http://www.baidu.com/2019/05/06/django/</id>
    <published>2019-05-05T20:38:32.000Z</published>
    <updated>2019-05-05T12:56:58.488Z</updated>
    
    <content type="html"><![CDATA[<p>NULL</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NULL&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://www.baidu.com/2019/05/06/nginx/"/>
    <id>http://www.baidu.com/2019/05/06/nginx/</id>
    <published>2019-05-05T19:56:58.000Z</published>
    <updated>2019-05-05T12:18:50.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx服务"><a href="#Nginx服务" class="headerlink" title="Nginx服务"></a>Nginx服务</h2><h2 id="Nginx现状"><a href="#Nginx现状" class="headerlink" title="Nginx现状"></a>Nginx现状</h2><p>​nginx 是当前的使用最广泛的webserver ,支持http正向/反向代理，支持TCP/UDP层代理，nginx在全部网站中占比较高，而且一直在增加。当下最时尚的webserver非nginx莫属。</p><h2 id="Nginx特点"><a href="#Nginx特点" class="headerlink" title="Nginx特点"></a>Nginx特点</h2><ul><li>性能好<ul><li>非阻塞IO/高并发(asyncio/aiohttp),支持文件IO</li><li>多worker，thread pool（线程池- 线程队列）</li><li>基于rbtree的定时器</li><li>系统特性的持续支持</li></ul></li><li>功能强大<ul><li>webserver/cache/keepalive/pipeline等等</li><li>各种upstream的支持【fastcgi/http/…】</li><li>输出灵活【chunk/zip/…】</li><li>在不断的发展 http2,tcp,udp,proxy…</li></ul></li><li>运维的友好【这个对于开发和部署很重要】<ul><li>配置非常规范【个人认为：约定及规范是最好的实践】</li><li>热加载和热更新【后文会详细介绍，能在二进制的层面热更新】</li><li>日志强大【真的很强的，很多变量支撑】</li></ul></li><li>扩展强大</li></ul><p>​     下图是nginx、apache和lighttpd的一个对比。系统压力，内存占用，upstream支持等多个方面都非常不错<br>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cuihuan.net/wp_content/new/nginx1/nginx_compare.png" alt="nginx对比图](nginx/nginx_compare.png)" title>                </div>                <div class="image-caption">nginx对比图](nginx/nginx_compare.png)</div>            </figure></p><p>HTTPS = HTTP + SSL</p><h2 id="Nginx工作原理"><a href="#Nginx工作原理" class="headerlink" title="Nginx工作原理"></a>Nginx工作原理</h2><p>​Nginx的运行方式：<code>master-worker多进程模式运行，单线程/非阻塞执行</code></p><p>​Nginx 启动后生成master，master会启动conf数量的<code>worker进程</code>，当用户的请求过来之后，由不同的worker调起<code>执行线程</code>，非阻塞的执行请求。这种运行方式相对于<code>apache的进程执行</code>相对轻量很多，支撑的并发性也会高很多。   </p><p>​Nginx 默认采用守护模式启动，守护模式让master进程启动后在后台运行。在Nginx运行期间主要由一个master主进程和多个worker进程（worker数目一般与cpu数目相同）</p><h3 id="1-master主进程"><a href="#1-master主进程" class="headerlink" title="(1)master主进程"></a>(1)master主进程</h3><ul><li>master主进程主要是管理worker进程，对网络事件进行收集和分发：</li></ul><ol><li>接收来自外界的信号</li><li>向各worker进程发送信号</li><li>监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程</li></ol><h3 id="2-worker-工作进程"><a href="#2-worker-工作进程" class="headerlink" title="(2)worker 工作进程"></a>(2)worker 工作进程</h3><p>​     nginx用一个独立的worker进程来处理一个请求，一个worker进程可以处理多个请求：</p><p>​     a.  当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接。</p><p>​     b.  一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。采用这种方式的好处：</p><ul><li><ul><li>节省锁带来的开销。对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查上时，也会方便很多</li><li>独立进程，减少风险。</li><li>采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快重新启动新的worker进程。</li><li>在一次请求里无需进程切换</li></ul></li></ul><h3 id="3-Nginx的IO处理过程"><a href="#3-Nginx的IO处理过程" class="headerlink" title="(3) Nginx的IO处理过程"></a>(3) Nginx的IO处理过程</h3><p>​一般的Tcp Socket处理过程：</p><p>​服务端：fd = socket.socket   —&gt; fd.bind()   —&gt; fd.listen()   —&gt; accept()  等待客户端连接  —&gt;  send / recv  —&gt; close()</p><p>客户端：fd = socket.socket  —&gt; fd.connect()  与服务端建立连接  —&gt; recv / send   —&gt; close()</p><p>​Nginx的网络IO处理通常使用epoll，epoll函数使用了I/O复用模型。与I/O阻塞模型比较，I/O复用模型的优势在于可以同时等待多个（而不只是一个）套接字描述符就绪。Nginx的epoll工作流程如下：</p><ul><li><ul><li>master进程先建好需要listen的socket后，然后再fork出多个woker进程，这样每个work进程都可以去accept这个socket</li><li>当一个client连接到来时，所有accept的work进程都会受到通知，但只有一个进程可以accept成功，其它的则会accept失败，Nginx提供了一把共享锁accept_mutex来保证同一时刻只有一个work进程在accept连接，从而解决惊群问题。</li><li>当一个worker进程accept这个连接后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完成的请求就结束了.</li></ul></li></ul><h2 id="Nginx-安装与配置"><a href="#Nginx-安装与配置" class="headerlink" title="Nginx 安装与配置"></a>Nginx 安装与配置</h2><p>​Nginx服务学习我们借助于一个第三方库Openresty，它本身就是把nginx核心代码做了一层封装，你完全可以把它当成Nginx使用。</p><p>​OpenResty 是一个基于 <a href="https://openresty.org/cn/nginx.html" target="_blank" rel="noopener">Nginx</a> 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p><p>​OpenResty 的目标是让你的Web服务直接跑在 <a href="https://openresty.org/cn/nginx.html" target="_blank" rel="noopener">Nginx</a> 服务内部，充分利用 <a href="https://openresty.org/cn/nginx.html" target="_blank" rel="noopener">Nginx</a> 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。</p><p>Openresty下载页：</p><p><a href="https://openresty.org/cn/download.html" target="_blank" rel="noopener">https://openresty.org/cn/download.html</a></p><p>下载版本：wget  <a href="https://openresty.org/download/openresty-1.11.2.5.tar.gz" target="_blank" rel="noopener">https://openresty.org/download/openresty-1.11.2.5.tar.gz</a>  (Ubuntu 16.x)</p><p>最新版本： wget  <a href="https://openresty.org/download/openresty-1.13.6.2.tar.gz" target="_blank" rel="noopener">https://openresty.org/download/openresty-1.13.6.2.tar.gz</a> (Ubuntu 17.10)</p><p>性能测试工具 Apache AB test</p><p>安装过程：</p><p>（1）安装依赖库：</p><pre><code>sudo apt install libpcre3  libpcre3-devsudo apt install openssl libssl-dev</code></pre><p>（2）安装openresty </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#将openresty安装到/opt/openresty目录下</span><br><span class="line">sudo mkdir /opt/openresty   </span><br><span class="line">#修改组和用户权限 apple用户名 : apple组</span><br><span class="line">sudo chown -Rf apple:apple /opt/openresty/</span><br><span class="line">tar -xzvf openresty-1.11.2.5.tar.gz</span><br><span class="line">cd openresty-1.11.2.5 </span><br><span class="line">./configure  --prefix=/opt/openresty    (注:./configure --help 查看更多的配置选项)</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>至此，安装完成，安装openresty就在/opt/openresty目录下。</p><p>（3）目录介绍</p><pre><code>bin                          openresty 的启动文件COPYRIGHT             版权文件luajit                        lua虚拟环境luajitlualib                       lua实现的第三方库，包括redis， mysql， upload， upstream，websocket等等。nginx                      nginx核心功能块pod     resty.index    site</code></pre><p>​openresty不只是提供了nginx功能，而且提供了丰富的工具集，我们可以做除了负载均衡和反向代理之外的很多事情，快速搭建出高性能web服务。</p><p>查看进程和端口：</p><p>ps -ef | grep 80</p><p>netstat -tunpl | grep 80  # </p><p>修改  vim  /opt/openresty/nginx/conf/nginx.conf 中，将listen 80改成 8080</p><p>启动nginx服务：</p><p>$ /opt/openresty/nginx/sbin/nginx</p><p>打开页面：<a href="http://172.16.245.180:8080/" target="_blank" rel="noopener">http://172.16.245.180:8080/</a> </p><p>​          <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p>可以看到 Welcome   to  OpenResty ！ 的页面，表示已经安装成功！</p><p>如果之前已安装了nginx 删除或停止它的服务：</p><p>​sudo apt remove nginx 或</p><p>​sudo servie nginx stop </p><h2 id="5-OpenResty-使用"><a href="#5-OpenResty-使用" class="headerlink" title="5 OpenResty 使用"></a>5 OpenResty 使用</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Openresty 框架的配置和nginx配置方法一样，配置文件: /opt/openresty/nginx/conf/nginx.conf</p><p>​Nginx主要通过nginx.conf文件进行配置使用。在nginx.conf文件中主要分为：</p><ul><li><ul><li>全局块：一些全局的属性，在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等</li><li>event块：参考事件模型，单个进程最大连接数等</li><li>http块：设定http服务器</li><li>server块：配置虚拟主机</li><li>location块：配置请求路由及页面的处理情况等</li></ul></li></ul><p>关键参数说明：</p><p>nginx进程数，建议设置为等于CPU总核心数。</p><p>worker_processes 8;</p><p>全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</p><p>error_log /usr/local/nginx/logs/error.log info;</p><p>进程pid文件</p><p>pid /opt/openresty/nginx/logs/nginx.pid;</p><p>指定进程可以打开的最大描述符：数目</p><p>工作模式与连接数上限</p><p>这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</p><p>worker_rlimit_nofile 65535;</p><p>虚拟主机的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    #监听端口</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    #域名可以有多个，用空格隔开, cat /etc/hosts</span><br><span class="line">    server_name www.jd.com jd.com; </span><br><span class="line">    index index.html index.htm index.php;</span><br><span class="line">    root /data/www/jd;</span><br><span class="line">    </span><br><span class="line">    #url 请求路由</span><br><span class="line">    location  /hello &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        content_by_lua &apos;</span><br><span class="line">            ngx.say(&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;)</span><br><span class="line">        &apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#负载均衡配置</span><br><span class="line">upstream piao.jd.com &#123;</span><br><span class="line">    #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weight参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">    server 192.168.80.121:80 weight=3;</span><br><span class="line">    server 192.168.80.122:80 weight=2;</span><br><span class="line">    server 192.168.80.123:80 weight=3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><p>拷贝我们的工程文件 artproject.zip，解压到某一个目录 eg:  /home/apple根目录下</p><p>配置nginx配置文件nginx.conf，添加如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /hello</span><br><span class="line">&#123;</span><br><span class="line">   default_type   text/html;</span><br><span class="line">   content_by_lua  &apos;</span><br><span class="line">       ngx.say(&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;)&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 静态文件，nginx自己处理</span><br><span class="line">location  ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">   root   /home/apple/artproject/art;</span><br><span class="line">   # 过期1天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。</span><br><span class="line">   expires  1d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$ /opt/openresty/nginx/sbin/nginx -s stop, quit, reopen, reload</p><p>$ /opt/openresty/nginx/sbin/nginx -t  测试</p><p>nginx: the configuration file /opt/openresty/nginx/conf/nginx.conf syntax is ok</p><p>nginx: configuration file /opt/openresty/nginx/conf/nginx.conf test is successful</p><p>查看页面效果</p><p><a href="http://172.16.245.180:8080/hello" target="_blank" rel="noopener">http://172.16.245.180:8080/hello</a></p><p><a href="http://172.16.245.180:8080/static/admin/pages/index.html" target="_blank" rel="noopener">http://172.16.245.180:8080/static/admin/pages/index.html</a></p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>​负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><p>​Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略</p><h4 id="RR-（轮询策略）"><a href="#RR-（轮询策略）" class="headerlink" title="RR （轮询策略）"></a>RR （轮询策略）</h4><p>​按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。虽然这种方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。</p><h4 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h4><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">    server localhost:8080 weight=9;</span><br><span class="line">    server localhost:8081 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时8080和8081分别占90%和10%。</p><h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>fair(第三方) </li></ol><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    fair; </span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>url_hash(第三方) </li></ol><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    hash $request_uri; </span><br><span class="line">    hash_method crc32; </span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理动态请求转发到某一个服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">​         location = / &#123;  </span><br><span class="line"></span><br><span class="line">​                  proxy_pass   http://localhost:8080  </span><br><span class="line"></span><br><span class="line">​       &#125;</span><br></pre></td></tr></table></figure></p><p>​此处的proxy_pass 对应的服务，会导到上述upstream入口</p><h3 id="作为静态资源服务器"><a href="#作为静态资源服务器" class="headerlink" title="作为静态资源服务器"></a>作为静态资源服务器</h3><p>​Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作（CDN），这就是网站静态化处理的核心思路。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 静态文件，nginx自己处理</span><br><span class="line">location  ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">   root   /home/apple/artproject/art;</span><br><span class="line">   # 过期1天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。</span><br><span class="line">   expires  1d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于URL路由规则"><a href="#关于URL路由规则" class="headerlink" title="关于URL路由规则"></a>关于URL路由规则</h3><p>语法规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location [=|~|~*|^~] /uri/ </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">​     … </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>= 开头表示精确匹配</p><p>^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。</p><p>~ 开头表示区分大小写的正则匹配</p><p>~*  开头表示不区分大小写的正则匹配</p><p>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配 的正则</p><p>/ 通用匹配，任何请求都会匹配到。</p><p>多个location配置的情况下匹配顺序为：</p><p>首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</p><p>例子，有如下匹配规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">   #规则A</span><br><span class="line">&#125;</span><br><span class="line">location = /login &#123;</span><br><span class="line">   #规则B</span><br><span class="line">&#125;</span><br><span class="line">location ^~ /static/ &#123;</span><br><span class="line">   #规则C</span><br><span class="line">&#125;</span><br><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;</span><br><span class="line">   #规则D</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.png$ &#123;</span><br><span class="line">   #规则E</span><br><span class="line">&#125;</span><br><span class="line">location !~ \.xhtml$ &#123;</span><br><span class="line">   #规则F</span><br><span class="line">&#125;</span><br><span class="line">location !~* \.xhtml$ &#123;</span><br><span class="line">   #规则G</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">   #规则H</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么产生的效果如下:</p><p>访问根目录/， 比如<a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> 将匹配规则A<br>访问 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a> 将匹配规则B，<a href="http://localhost/register" target="_blank" rel="noopener">http://localhost/register</a> 则匹配规则H<br>访问 <a href="http://localhost/static/a.html" target="_blank" rel="noopener">http://localhost/static/a.html</a> 将匹配规则C<br>访问 <a href="http://localhost/a.gif" target="_blank" rel="noopener">http://localhost/a.gif</a>, <a href="http://localhost/b.jpg" target="_blank" rel="noopener">http://localhost/b.jpg</a> 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 <a href="http://localhost/static/c.png" target="_blank" rel="noopener">http://localhost/static/c.png</a> 则优先匹配到规则C<br>访问 <a href="http://localhost/a.PNG" target="_blank" rel="noopener">http://localhost/a.PNG</a> 则匹配规则E，而不会匹配规则D，因为规则E不区分大小写。</p><p>访问 <a href="http://localhost/a.xhtml" target="_blank" rel="noopener">http://localhost/a.xhtml</a> 不会匹配规则F和规则G，<a href="http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。" target="_blank" rel="noopener">http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。</a></p><p>访问 <a href="http://localhost/category/id/1111" target="_blank" rel="noopener">http://localhost/category/id/1111</a> 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Nginx服务&quot;&gt;&lt;a href=&quot;#Nginx服务&quot; class=&quot;headerlink&quot; title=&quot;Nginx服务&quot;&gt;&lt;/a&gt;Nginx服务&lt;/h2&gt;&lt;h2 id=&quot;Nginx现状&quot;&gt;&lt;a href=&quot;#Nginx现状&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="nginx" scheme="http://www.baidu.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://www.baidu.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>python设计模式</title>
    <link href="http://www.baidu.com/2019/05/06/python_design_pattern/"/>
    <id>http://www.baidu.com/2019/05/06/python_design_pattern/</id>
    <published>2019-05-05T19:27:52.000Z</published>
    <updated>2019-05-05T11:31:54.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="七大设计原则"><a href="#七大设计原则" class="headerlink" title="七大设计原则"></a>七大设计原则</h2><p>七大设计原则： </p><ul><li>1、单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】：一个类负责一项职责. </li><li>2、里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】：继承与派生的规则.（子类可替换父类） </li><li>3、依赖倒转原则【DEPENDENCE INVERSION PRINCIPLE】：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。 </li><li>4、接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 </li><li>5、迪米特法则【LOW OF DEMETER】：高内聚 低耦合 – high cohesion low coupling </li><li>6、开闭原则【OPEN CLOSE PRINCIPLE】：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 </li><li>7、组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】：尽量使用组合和聚合少使用继承的关系来达到复用的原则。</li></ul><h2 id="二十四种模式"><a href="#二十四种模式" class="headerlink" title="二十四种模式"></a>二十四种模式</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><ul><li>1、抽象工厂模式(Abstract factory pattern): 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要指定具体类. </li><li>2、生成器模式(Builder pattern): 使用生成器模式封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示. </li><li>3、工厂模式(factory method pattern): 定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类. </li><li>4、原型模式(prototype pattern): 当创建给定类的实例过程很昂贵或很复杂时, 就使用原形模式. </li><li>5、单例了模式(Singleton pattern): 确保一个类只有一个实例, 并提供全局访问点. </li><li>6、多例模式(Multition pattern): 在一个解决方案中结合两个或多个模式, 以解决一般或重复发生的问题. </li></ul><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><ul><li>1、适配器模式(Adapter pattern): 将一个类的接口, 转换成客户期望的另一个接口. 适配器让原本接口不兼容的类可以合作无间. 对象适配器使用组合, 类适配器使用多重继承. </li><li>2、桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变. </li><li>3、组合模式(composite pattern): 允许你将对象组合成树形结构来表现”整体/部分”层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合. </li><li>4、装饰者模式(decorator pattern): 动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案. </li><li>5、外观模式(facade pattern): 提供了一个统一的接口, 用来访问子系统中的一群接口. 外观定义了一个高层接口, 让子系统更容易使用. </li><li>6、亨元模式(Flyweight Pattern): 如想让某个类的一个实例能用来提供许多”虚拟实例”, 就使用蝇量模式. </li><li>7、代理模式(Proxy pattern): 为另一个对象提供一个替身或占位符以控制对这个对象的访问. </li></ul><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><ul><li>1、责任链模式(Chain of responsibility pattern): 通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象. </li><li>2、命令模式(Command pattern): 将”请求”封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作. </li><li>3、解释器模式(Interpreter pattern): 使用解释器模式为语言创建解释器. </li><li>4、迭代器模式(iterator pattern): 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示. </li><li>5、中介者模式(Mediator pattern) : 使用中介者模式来集中相关对象之间复杂的沟通和控制方式. </li><li>6、备忘录模式(Memento pattern): 当你需要让对象返回之前的状态时(例如, 你的用户请求”撤销”), 你使用备忘录模式. </li><li>7、观察者模式(observer pattern): 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新. </li><li>8、状态模式(State pattern): 允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类. </li><li>9、策略模式(strategy pattern): 定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户. </li><li>10、模板方法模式(Template pattern): 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤. </li><li>11、访问者模式(visitor pattern): 当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式.</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><pre><code>https://blog.csdn.net/weixin_41781973/article/details/80630337https://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#4130080https://www.cnblogs.com/Liqiongyu/p/5916710.html https://github.com/w392807287/Design_pattern_of_python</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;七大设计原则&quot;&gt;&lt;a href=&quot;#七大设计原则&quot; class=&quot;headerlink&quot; title=&quot;七大设计原则&quot;&gt;&lt;/a&gt;七大设计原则&lt;/h2&gt;&lt;p&gt;七大设计原则： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、单一职责原则【SINGLE RESPONSIBILITY P
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>django中的cookie，session</title>
    <link href="http://www.baidu.com/2019/05/02/django_cookie_session/"/>
    <id>http://www.baidu.com/2019/05/02/django_cookie_session/</id>
    <published>2019-05-01T19:30:43.000Z</published>
    <updated>2019-05-05T13:03:41.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Django中的cookie和session"><a href="#Django中的cookie和session" class="headerlink" title="Django中的cookie和session"></a>Django中的cookie和session</h2><p>Cookies ：是浏览器为 Web 服务器存储的一小段信息。 每次浏览器从某个服务器请求页面时，它收到服务器回发送过来的cookies。它保存在浏览器下的某个文件夹下。 </p><p>Session：Django的Session机制会向请求的浏览器发送cookie字符串。同时也会保存到本地一份，用来验证浏览器登录是否为同一用户。它存在于服务器，Django默认会把session存入到数据库中。</p><p>Session依赖于Cookie，如果浏览器不能保存cookies那么session就失效了。因为它需要浏览器的cookie值去session里做对比。session就是用来在服务器端保存用户的会话状态。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>1、获取Cookie：</p><p>request.COOKIES[‘key’]</p><p>request.get_signed_cookie(key, default=RAISE_ERROR, salt=’’, max_age=None)</p><p>参数：</p><pre><code>default: 默认值salt: 加密盐max_age: 后台控制过期时间</code></pre><p>2、设置Cookie：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rep = HttpResponse(...) 或 rep ＝ render(request, ...)</span><br><span class="line"></span><br><span class="line">rep.set_cookie(key,value,...)</span><br><span class="line">rep.set_signed_cookie(key,value,salt=&apos;加密盐&apos;,...)</span><br><span class="line">​    参数：</span><br><span class="line">​        key,              键</span><br><span class="line">​        value=&apos;&apos;,         值</span><br><span class="line">​        max_age=None,     超时时间</span><br><span class="line">​        expires=None,     超时时间(IE requires expires, so set it if hasn&apos;t been already.)</span><br><span class="line">​        path=&apos;/&apos;,         Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问</span><br><span class="line">​        domain=None,      Cookie生效的域名</span><br><span class="line">​        secure=False,     https传输</span><br><span class="line">​        httponly=False    只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</span><br></pre></td></tr></table></figure></p><p>由于cookie保存在客户端的电脑上，所以，JavaScript和jquery也可以操作cookie。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&apos;/static/js/jquery.cookie.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">$.cookie(&quot;list_pager_num&quot;, 30,&#123; path: &apos;/&apos; &#125;);</span><br></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Django中默认支持Session，其内部提供了5种类型的Session供开发者使用：</p><p>数据库（默认）<br>缓存<br>文件<br>缓存+数据库<br>加密cookie</p><h3 id="1、数据库Session"><a href="#1、数据库Session" class="headerlink" title="1、数据库Session"></a>1、数据库Session</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Django默认支持Session，并且默认是将Session数据存储在数据库中，即：django_session 表中。</span><br><span class="line"></span><br><span class="line">a. 配置 settings.py</span><br><span class="line"></span><br><span class="line">    SESSION_ENGINE = &apos;django.contrib.sessions.backends.db&apos;   # 引擎（默认）</span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                       # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）</span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_PATH ＝ &quot;/&quot;                               # Session的cookie保存的路径（默认）</span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_DOMAIN = None                             # Session的cookie保存的域名（默认）</span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_SECURE = False                            # 是否Https传输cookie（默认）</span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_HTTPONLY = True                           # 是否Session的cookie只支持http传输（默认）</span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_AGE = 1209600                             # Session的cookie失效日期（2周）（默认）</span><br><span class="line"></span><br><span class="line">    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                  # 是否关闭浏览器使得Session过期（默认）</span><br><span class="line"></span><br><span class="line">    SESSION_SAVE_EVERY_REQUEST = False                       # 是否每次请求都保存Session，默认修改之后才保存（默认）</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">b. 使用</span><br><span class="line"></span><br><span class="line">    def index(request):</span><br><span class="line">        # 获取、设置、删除Session中数据</span><br><span class="line">        request.session[&apos;k1&apos;]</span><br><span class="line">        request.session.get(&apos;k1&apos;,None)</span><br><span class="line">        request.session[&apos;k1&apos;] = 123</span><br><span class="line">        request.session.setdefault(&apos;k1&apos;,123) # 存在则不设置</span><br><span class="line">        del request.session[&apos;k1&apos;]</span><br><span class="line"></span><br><span class="line">        # 所有 键、值、键值对</span><br><span class="line">        request.session.keys()</span><br><span class="line">        request.session.values()</span><br><span class="line">        request.session.items()</span><br><span class="line">        request.session.iterkeys()</span><br><span class="line">        request.session.itervalues()</span><br><span class="line">        request.session.iteritems()</span><br><span class="line"></span><br><span class="line">        # 用户session的随机字符串</span><br><span class="line">        request.session.session_key</span><br><span class="line"></span><br><span class="line">        # 将所有Session失效日期小于当前日期的数据删除</span><br><span class="line">        request.session.clear_expired()</span><br><span class="line"></span><br><span class="line">        # 检查 用户session的随机字符串 在数据库中是否</span><br><span class="line">        request.session.exists(&quot;session_key&quot;)</span><br><span class="line"></span><br><span class="line">        # 删除当前用户的所有Session数据</span><br><span class="line">        request.session.delete(&quot;session_key&quot;)</span><br></pre></td></tr></table></figure><h3 id="2、缓存Session"><a href="#2、缓存Session" class="headerlink" title="2、缓存Session"></a>2、缓存Session</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a. 配置 settings.py</span><br><span class="line"></span><br><span class="line">    SESSION_ENGINE = &apos;django.contrib.sessions.backends.cache&apos;  # 引擎</span><br><span class="line">    SESSION_CACHE_ALIAS = &apos;default&apos;                            # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                        # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串</span><br><span class="line">    SESSION_COOKIE_PATH ＝ &quot;/&quot;                                # Session的cookie保存的路径</span><br><span class="line">    SESSION_COOKIE_DOMAIN = None                              # Session的cookie保存的域名</span><br><span class="line">    SESSION_COOKIE_SECURE = False                             # 是否Https传输cookie</span><br><span class="line">    SESSION_COOKIE_HTTPONLY = True                            # 是否Session的cookie只支持http传输</span><br><span class="line">    SESSION_COOKIE_AGE = 1209600                              # Session的cookie失效日期（2周）</span><br><span class="line">    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                   # 是否关闭浏览器使得Session过期</span><br><span class="line">    SESSION_SAVE_EVERY_REQUEST = False                        # 是否每次请求都保存Session，默认修改之后才保存</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b. 使用</span><br><span class="line"></span><br><span class="line">    同上</span><br></pre></td></tr></table></figure><h3 id="3、文件Session"><a href="#3、文件Session" class="headerlink" title="3、文件Session"></a>3、文件Session</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a. 配置 settings.py</span><br><span class="line"></span><br><span class="line">    SESSION_ENGINE = &apos;django.contrib.sessions.backends.file&apos;    # 引擎</span><br><span class="line">    SESSION_FILE_PATH = None                                    # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()                                                            # 如：/var/folders/d3/j9tj0gz93dg06bmwxmhh6_xm0000gn/T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;                          # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串</span><br><span class="line">    SESSION_COOKIE_PATH ＝ &quot;/&quot;                                  # Session的cookie保存的路径</span><br><span class="line">    SESSION_COOKIE_DOMAIN = None                                # Session的cookie保存的域名</span><br><span class="line">    SESSION_COOKIE_SECURE = False                               # 是否Https传输cookie</span><br><span class="line">    SESSION_COOKIE_HTTPONLY = True                              # 是否Session的cookie只支持http传输</span><br><span class="line">    SESSION_COOKIE_AGE = 1209600                                # Session的cookie失效日期（2周）</span><br><span class="line">    SESSION_EXPIRE_AT_BROWSER_CLOSE = False                     # 是否关闭浏览器使得Session过期</span><br><span class="line">    SESSION_SAVE_EVERY_REQUEST = False                          # 是否每次请求都保存Session，默认修改之后才保存</span><br><span class="line"></span><br><span class="line">b. 使用</span><br><span class="line"></span><br><span class="line">    同上</span><br></pre></td></tr></table></figure><h3 id="4、缓存-数据库Session"><a href="#4、缓存-数据库Session" class="headerlink" title="4、缓存+数据库Session"></a>4、缓存+数据库Session</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数据库用于做持久化，缓存用于提高效率</span><br><span class="line"></span><br><span class="line">a. 配置 settings.py</span><br><span class="line"></span><br><span class="line">    SESSION_ENGINE = &apos;django.contrib.sessions.backends.cached_db&apos;        # 引擎</span><br><span class="line"></span><br><span class="line">b. 使用</span><br><span class="line"></span><br><span class="line">    同上</span><br></pre></td></tr></table></figure><h3 id="5、加密cookie-Session"><a href="#5、加密cookie-Session" class="headerlink" title="5、加密cookie Session"></a>5、加密cookie Session</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a. 配置 settings.py</span><br><span class="line"></span><br><span class="line">    SESSION_ENGINE = &apos;django.contrib.sessions.backends.signed_cookies&apos;   # 引擎</span><br><span class="line"></span><br><span class="line">b. 使用</span><br><span class="line"></span><br><span class="line">    同上</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render,redirect</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line">def login(request):</span><br><span class="line">    print(&quot;COOKIES&quot;,request.COOKIES)  #打印cookies 一个字典，里面多个键值对</span><br><span class="line">    print(&quot;SESSION&quot;,request.session)  #session为服务器对应客户信息的键</span><br><span class="line"></span><br><span class="line">    if request.method==&quot;POST&quot;:</span><br><span class="line">        name=request.POST.get(&quot;user&quot;)</span><br><span class="line">        pwd=request.POST.get(&quot;pwd&quot;)</span><br><span class="line">        if name==&quot;yuan&quot; and pwd==&quot;123&quot;:</span><br><span class="line"></span><br><span class="line">            # ret=redirect(&quot;/index/&quot;)</span><br><span class="line">            # 给对象ret设置cookie 安全性较差  ,设定有效时间max_age，expires，</span><br><span class="line">            # ret.set_cookie(&quot;username&quot;,&#123;&quot;11&quot;:&quot;22&quot;&#125;,max_age=10,expires=datetime.datetime.utcnow()+datetime.timedelta(days=3))</span><br><span class="line">            # return ret</span><br><span class="line"></span><br><span class="line">            # COOKIE SESSION一起使用</span><br><span class="line">            # session 以字典存放在服务器端，发给客户端的是数据对应的键，</span><br><span class="line">            request.session[&quot;is_login&quot;]=True  # 在session中增加键值对</span><br><span class="line">            request.session[&quot;user&quot;]=name</span><br><span class="line"></span><br><span class="line">            return redirect(&quot;/index/&quot;)</span><br><span class="line"></span><br><span class="line">    return render(request,&quot;login.html&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    if request.COOKIES.get(&quot;username&quot;,None):   # 取不到设置默认值为None</span><br><span class="line">        name = request.COOKIES.get(&quot;username&quot;,None)</span><br><span class="line">        return render(request, &quot;index.html&quot;, locals())</span><br><span class="line"></span><br><span class="line">    # session验证 存在数据库中，所以要先makemigrations生成数据库</span><br><span class="line">    if request.session.get(&quot;is_login&quot;,None):</span><br><span class="line">        name=request.session.get(&quot;user&quot;,None)</span><br><span class="line">        return render(request,&quot;index.html&quot;,locals())</span><br><span class="line">    else:</span><br><span class="line">        return redirect(&quot;/login/&quot;)</span><br><span class="line">##session获取</span><br><span class="line">request.session.get(&quot;user&quot;,None)</span><br><span class="line"># 设置</span><br><span class="line">request.session[&quot;user&quot;]=name</span><br><span class="line"># 删除</span><br><span class="line">del request.session.get(&quot;user&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Django中的cookie和session&quot;&gt;&lt;a href=&quot;#Django中的cookie和session&quot; class=&quot;headerlink&quot; title=&quot;Django中的cookie和session&quot;&gt;&lt;/a&gt;Django中的cookie和sessi
      
    
    </summary>
    
      <category term="django" scheme="http://www.baidu.com/categories/django/"/>
    
    
      <category term="django" scheme="http://www.baidu.com/tags/django/"/>
    
      <category term="cookie" scheme="http://www.baidu.com/tags/cookie/"/>
    
      <category term="session" scheme="http://www.baidu.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>LVS</title>
    <link href="http://www.baidu.com/2019/04/18/LVS/"/>
    <id>http://www.baidu.com/2019/04/18/LVS/</id>
    <published>2019-04-18T15:22:43.000Z</published>
    <updated>2019-05-05T07:30:06.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h1><p>LVS(linux virtual server)即linux虚拟服务器，是一个虚拟的服务器集群系统。</p><p>使用集群技术和Linux操作系统实现一个高性能,高可用的服务器,很好的可伸缩性(scalability),很好的可靠性(reliability),很好的可管理性(manageability).</p><p>contos7:</p><p>grep -i ipvs /boot/config-3.10.0-693.e17.x86_64</p><p>grep -i ipvs -C 10 /boot/config-3.10.0-693.e17.x86_64</p><p>yum install ipvsadm</p><p>rpm -ql ipvsadm</p><p>curl命令</p><p>lvs服务器:<br>需要两块网卡</p><p>启用Ipforward：</p><pre><code>echo net.ipv4.ip_forward=1 &gt;&gt; /etc/sysctl.conf</code></pre><p>sysctl -p</p><p>sysctl -a | grep ip_forward</p><p>iptables -vnl</p><p>client：<br>需要桥接</p><p>RS1：<br>设置网关</p><pre><code>yum install httpdecho RS1 &gt; /var/www/html/index.html</code></pre><p>RS2；<br>设置网关</p><pre><code>yum install httpdecho RS2 &gt; /var/www/html/index.html</code></pre><p>LVS：</p><p>定义ipvs规则:NAt模式</p><pre><code>yum install ipvsadmipvsadm -A -t 172.20.0.200:80 -s rripvsadm -Lnipvsadm -a -t 172.20.0.200:80  -r 192.168.80.17 -mipvsadm -a -t 172.20.0.200:80  -r 192.168.80.27 -mipvsadm -Ln</code></pre><p>并发4百万 apache 1万</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="Cluster概念"><a href="#Cluster概念" class="headerlink" title="Cluster概念"></a>Cluster概念</h3><ul><li><p>系统扩展方式：</p><pre><code>scale up: 向上扩展，增强scale out: 向外扩展，增加设备，调度分配问题， cluster</code></pre></li><li><p>Cluster: 集群，未解决某个特定问题将多台计算机组合起来形成的单个系统</p></li><li><p>Linux Cluster类型：<br>  LB：load blancing, 负载均衡<br>  HA：high availiablity, 高可用， spof(single point of failure)</p><pre><code>MTBF: Mean Time Between Failure 平均无故障时间MTTR: Mean Time To REStoration (repair) 平均恢复前时间（故障时间）A=MTBF/(MTBF+MTTR) (0,1): 99%,99.5%, 99.9%, 99.99%, 99.999%</code></pre><p>  HPC: high-performance computing . 高性能 <a href="http://www.top500.org" target="_blank" rel="noopener">www.top500.org</a></p></li><li>分布式系统：<pre><code>分布式存储： 云盘分布式计算： hadoop, spark</code></pre></li></ul><h3 id="Cluster分类"><a href="#Cluster分类" class="headerlink" title="Cluster分类"></a>Cluster分类</h3><ul><li>LB Cluster的实现</li><li>硬件：<pre><code>F5 big-ipcitrix netscalerA10 A10</code></pre></li><li>软件:<pre><code>lvs: linux virtual servernginx: 支持七层调度haproxy: 支持七层调度ats: apache trafficserverperlbal: perl编写pound</code></pre></li><li>基于工作的协议层划分：</li><li>传输层（通用）：DPORT<br>  LVS：<br>  nginx：stream<br>  haproxy: mode tcp</li><li><p>应用层（专用）：针对特定协议，自定义的请求模型分类<br>  proxy server：</p><pre><code>http:nginx, httpdm haproxy(mode http),...fastcgi: nginx, httpd, ...mysql: mysql-proxy,...</code></pre></li><li><p>会话保持：负载均衡</p><pre><code>（1）session sticky: 同一用户调度固定服务器    source ip: lvs sh算法（对某一特定服务而言）    cookie（2）session replication: 每台服务器拥有全部session        session multicast cluster（3）session server: 专门的session服务器            memcached， redis</code></pre></li><li>HA集群实现方案<br>  keepalived: vrrp协议<br>  ais：应用接口规范<pre><code>heartbeatcman + rgmanager(RHCS)coresync_pacemaker</code></pre></li></ul><h2 id="LVS介绍"><a href="#LVS介绍" class="headerlink" title="LVS介绍"></a>LVS介绍</h2><h3 id="LVS介绍-1"><a href="#LVS介绍-1" class="headerlink" title="LVS介绍"></a>LVS介绍</h3><ul><li>LVS: linux virtual server, 负载调度器，集成内核<br>  官网：<a href="http://www.linuxvirtualserver.org/" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/</a><br>  VS：virtual server，负责调度<br>  RS：real server,负责真正提供服务<br>  L4：四层路由器或交换机</li><li>工作原理：vs根据请求报文的目标ip和目标协议及端口将其调度转发至某RS，根据调度算法来挑选RS</li><li>iptables/netfilter:<br>  iptables:用户空间的管理工具<br>  netfilter:内核空间上的框架<br>  流入：PREROUTING–&gt;INPUT<br>  流出：OUTPUT–&gt; POSTROUTING<br>  转发：PREROUTING–&gt;FORWARD–&gt;POSTROUTING<br>  DNAT：目标地址转换；PREROUTING</li></ul><h3 id="LVS概念"><a href="#LVS概念" class="headerlink" title="LVS概念"></a>LVS概念</h3><ul><li><p>lvs集群类型中的术语：<br>  VS：virtual server, director server(DS)</p><pre><code>dispatcher(调度器)，load balancer</code></pre><p>  RS:real server(lvs), upstream server(nginx)</p><pre><code>backend server(haproxy)</code></pre><p>  CIP:client ip<br>  VIP:virtual serve ip  VS外网的ip<br>  DIP:director ip  VS内网Ip<br>  RIP:real server ip</p><p>  访问流程：CIP<-->VIP==DIP<-->RIP</--></--></p></li></ul><h3 id="LVS集群的类型"><a href="#LVS集群的类型" class="headerlink" title="LVS集群的类型"></a>LVS集群的类型</h3><ul><li><p>lvs: ipvsadm/ipvs<br>  ipvsadm: 用户空间的命令行工具，规则管理器<br>  ipvs: 工作于内核空间netfilter的INPUT钩子上的框架</p></li><li><p>lvs集群的类型：<br>  lvs-nat: 修改请求报文的目标IP，多目标IP的DNAT<br>  lvs-dr: 操纵封装新的MAC地址<br>  lvs-tun: 在原请求IP报文之外新加一个IP首部<br>  lvs-fullnat: 修改请求报文的源和目标IP</p></li></ul><h3 id="lvs-nat模式"><a href="#lvs-nat模式" class="headerlink" title="lvs-nat模式"></a>lvs-nat模式</h3><ul><li>lvs-nat:<br>  本质是多目标IP的DNAT，通过将请求报文中的目标地址和目标端口修改为某挑出的RS的RIP和PORT实现转发<br>  (1)RIP和DIP应在同一个IP网络，且应使用私网地址，RS的网关要指向DIP<br>  (2)请求报文和响应报文都必须经由Director转发，Director易于成为系统瓶颈<br>  (3)支持端口映射，可修改请求报文的目标PORT<br>  (4)VS必须是linux系统，RS可以是任意OS系统</li></ul><h3 id="lvs-fullnat模式"><a href="#lvs-fullnat模式" class="headerlink" title="lvs-fullnat模式"></a>lvs-fullnat模式</h3><ul><li>lvs-fullnat:<br>  通过同时修改请求报文的源IP地址和目标IP地址进行转发<pre><code>CIP--&gt;DIPVIP--&gt;RIP</code></pre>  (1)VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此。RIP的网关一般不会指向DIP<br>  (2)RS收到的请求报文源地址是DIP，因此，只需响应给DIP；但Director还要将其发往Client<br>  (3)请求和响应报文都经由Director<br>  (4)支持端口映射<br>  注意：此类型kernel默认不支持</li></ul><h3 id="LVS工作模式总结"><a href="#LVS工作模式总结" class="headerlink" title="LVS工作模式总结"></a>LVS工作模式总结</h3><table><thead><tr><th></th><th>VS/NAT</th><th>VS/TUN</th><th>VS/DR</th></tr></thead><tbody><tr><td>server</td><td>any</td><td>tunneling</td><td>non-arp device</td></tr><tr><td>server network</td><td>private</td><td>LAN/WAN</td><td>LAN</td></tr><tr><td>server number</td><td>low(10~20)</td><td>high(100)</td><td>high(100)</td></tr><tr><td>server gateway</td><td>load balancer</td><td>own router</td><td>own router</td></tr></tbody></table><ul><li><p>lvs-nat与lvs-fullnat:请求和响应报文都经由director<br>  lvs-nat:RIP的网关要指向DIP<br>  lvs-fullnat：RIP和DIP未必在同一IP网络，但要能通信</p></li><li><p>lvs-dr与lvs-tun:请求报文要经由director，但相应报文有RS直接发往client<br>  lvs-dr：通过封装新的MAC首部实现，通过MAC网络转发<br>  lvs-tun: 通过在院IP报文外封装新IP头实现转发，支持远距离通信</p></li></ul><h3 id="ipvs-scheduler"><a href="#ipvs-scheduler" class="headerlink" title="ipvs scheduler"></a>ipvs scheduler</h3><ul><li>ipvs scheduler:<br>  根据其调度时是否考虑各RS当前的负载状态<br>  两种：静态方法和动态方法</li><li><p>静态方法：仅根据算法本身进行调度</p><pre><code>1. RR: roundrobin,轮询2. WRR: weighted RR,加权轮询3. SH: source hashing,实现session sticky，源IP地址hash；将来自同一个IP地址的请求，始终发往第一次挑中的RS，从而实现会话绑定4. DH: destination hashing, 目标地址哈希，将发往同一个目标地址的骑牛始终发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡；如：宽带运行商</code></pre></li><li><p>动态方法：<br>  主要根据每个RS当前的负载状态及调度算法进行调度overhead=value较小的RS将被调度</p><ol><li>LC: least connections 适用于长连接应用<br> overhead=activeconns*256+inactiveconns</li><li>WLC: weighted LC,默认调度方法<br> overhead=(acticeconns*256+inactiveconns)/weight</li><li>SED: shortest expection delay,初始连接高权重优先<br> overhead=(activeconns+1)*256/weight</li><li>NQ: never queue, 第一轮均匀分配，后续sed</li><li>LBLC: locality-based LC，动态的DH算法，使用场景：根据负载状态实现正向代理</li><li>LBLCR: LBLC with replication, 带复制功能的LBLC，解决LBLC负载不均衡问题，从负载重的复制到负载轻的RS</li></ol></li></ul><h3 id="ipvsadm命令"><a href="#ipvsadm命令" class="headerlink" title="ipvsadm命令"></a>ipvsadm命令</h3><ul><li>ipvsadm 命令：</li><li><p>核心功能：</p><pre><code>集群服务管理：增，删，改集群服务的RS管理：增，删，改查看</code></pre><p>  ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] [-M netmask] [–pe persistence_engine] [-b sched-flags]<br>  ipvsadm -D -t|u|f service-address 删除<br>  ipvsadm -C 清空<br>  ipvsadm -R 重载<br>  ipvsadm -S [-n] 保存<br>  ipvsadm -a|e -t|u|f service-address -r server-address [options]<br>  ipvsadm -d -t|u|f service-address -r server-address<br>  ipvsadm -L|l [options]<br>  ipvsadm -Z [-t|U|f service-address]</p></li><li><p>管理集群上的RS：增，删，改</p></li><li>增、改：ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m]  [-w weight]</li><li>删：ipvsadm -d -t|u|f service-address -r server-address</li><li>server-addres:<br>  rip[:port] 如省略port，不作端口映射</li><li>选项：<br>  lvs类型:<pre><code>-g: gateway, dr类型，默认-i: ipip，tun类型-m: masquerade, nat类型</code></pre>  -w weight: 权重</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sina.com.cn/s/blog_6786545e0102vjvq.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6786545e0102vjvq.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LVS&quot;&gt;&lt;a href=&quot;#LVS&quot; class=&quot;headerlink&quot; title=&quot;LVS&quot;&gt;&lt;/a&gt;LVS&lt;/h1&gt;&lt;p&gt;LVS(linux virtual server)即linux虚拟服务器，是一个虚拟的服务器集群系统。&lt;/p&gt;
&lt;p&gt;使用集群技术和
      
    
    </summary>
    
      <category term="lvs" scheme="http://www.baidu.com/categories/lvs/"/>
    
    
      <category term="lvs" scheme="http://www.baidu.com/tags/lvs/"/>
    
  </entry>
  
  <entry>
    <title>django集成celery</title>
    <link href="http://www.baidu.com/2019/04/18/django_celery/"/>
    <id>http://www.baidu.com/2019/04/18/django_celery/</id>
    <published>2019-04-17T19:22:43.000Z</published>
    <updated>2019-05-05T12:39:42.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Django集成Celery到项目"><a href="#Django集成Celery到项目" class="headerlink" title="Django集成Celery到项目"></a>Django集成Celery到项目</h2><p>将celery集成到Django项目中，实现异步任务处理和定时任务处理</p><h2 id="Celery工作流程"><a href="#Celery工作流程" class="headerlink" title="Celery工作流程"></a>Celery工作流程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/04/18/django_celery/django/celery.png" alt="celery流程图" title>                </div>                <div class="image-caption">celery流程图</div>            </figure><p>Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。</p><p><strong>消息中间件</strong></p><p>Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，RabbitMQ, Redis, MongoDB (experimental), Amazon SQS (experimental),CouchDB (experimental), SQLAlchemy (experimental),Django ORM (experimental), IronMQ</p><p><strong>任务执行单元</strong></p><p>Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。</p><p><strong>任务结果存储</strong></p><p>Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, Redis，memcached, MongoDB，SQLAlchemy, Django ORM，Apache Cassandra, IronCache</p><h2 id="1-Celery安装与配置"><a href="#1-Celery安装与配置" class="headerlink" title="1.Celery安装与配置"></a>1.Celery安装与配置</h2><p>在虚拟环境中安装:</p><pre><code>pip install django-celery==3.2.2pip install  django-redispip install flower   # celery  的web管理平台(异步任务可视化)</code></pre><p>查看集成到Django中的celery版本， pip  freeze</p><p> celery==3.1.26.post2      django-celery==3.2.2    flower==0.9.2</p><p>启动redis服务， 端口假设为6379</p><p>发现pip安装比较慢的情况</p><p>pip  install pillow  -i  <a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a>    </p><h2 id="2-Django中配置"><a href="#2-Django中配置" class="headerlink" title="2.Django中配置"></a>2.Django中配置</h2><h3 id="（1）在主工程的配置文件settings-py-中应用注册表INSTALLED-APPS中加入-djcelery"><a href="#（1）在主工程的配置文件settings-py-中应用注册表INSTALLED-APPS中加入-djcelery" class="headerlink" title="（1）在主工程的配置文件settings.py 中应用注册表INSTALLED_APPS中加入 djcelery"></a>（1）在主工程的配置文件settings.py 中应用注册表INSTALLED_APPS中加入 djcelery</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &apos;django.contrib.admin&apos;,</span><br><span class="line">    &apos;django.contrib.auth&apos;,</span><br><span class="line">    &apos;django.contrib.contenttypes&apos;,</span><br><span class="line">    &apos;django.contrib.sessions&apos;,</span><br><span class="line">    &apos;django.contrib.messages&apos;,</span><br><span class="line">    &apos;django.contrib.staticfiles&apos;,</span><br><span class="line">    &apos;art&apos;,</span><br><span class="line">    &apos;xadmin&apos;,</span><br><span class="line">    &apos;crispy_forms&apos;,</span><br><span class="line">    &apos;DjangoUeditor&apos;,</span><br><span class="line">    &apos;djcelery&apos;,       #加入djcelery</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="2-在settings-py-中加入celery配置信息"><a href="#2-在settings-py-中加入celery配置信息" class="headerlink" title="(2) 在settings.py 中加入celery配置信息"></a>(2) 在settings.py 中加入celery配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># celery 配置信息 start</span><br><span class="line"></span><br><span class="line">import djcelery</span><br><span class="line">djcelery.setup_loader()</span><br><span class="line">BROKER_URL = &apos;redis://127.0.0.1:6379/1&apos;</span><br><span class="line">CELERY_IMPORTS = (&apos;art.tasks&apos;)</span><br><span class="line">CELERY_TIMEZONE = &apos;Asia/Shanghai&apos;</span><br><span class="line">CELERYBEAT_SCHEDULER = &apos;djcelery.schedulers.DatabaseScheduler&apos; </span><br><span class="line">from celery.schedules import crontab</span><br><span class="line">from celery.schedules import timedelta</span><br><span class="line"></span><br><span class="line">CELERYBEAT_SCHEDULE = &#123;    #定时器策略</span><br><span class="line">    #定时任务一：　每隔30s运行一次</span><br><span class="line">    u&apos;测试定时器1&apos;: &#123;</span><br><span class="line">        &quot;task&quot;: &quot;art.tasks.tsend_email&quot;,</span><br><span class="line">        #&quot;schedule&quot;: crontab(minute=&apos;*/2&apos;),  # or &apos;schedule&apos;:   timedelta(seconds=3),</span><br><span class="line">        &quot;schedule&quot;:timedelta(seconds=30),</span><br><span class="line">        &quot;args&quot;: (),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># celery 配置信息 end</span><br></pre></td></tr></table></figure><p>​      当djcelery.setup_loader()运行时，Celery便会去查看INSTALLD_APPS下包含的所有app目录中的tasks.py文件，找到标记为task的方法，将它们注册为celery task</p><p>​     BROKER_URL：broker是代理人，它负责分发任务给worker去执行。我使用的是Redis作为broker</p><p>​    没有设置 CELERY_RESULT_BACKEND，默认没有配置，此时Django会使用默认的数据库(也是你指定的orm数据库)。</p><p>   CELERY_IMPORTS：是导入目标任务文件</p><p>   CELERYBEAT_SCHEDULER：使用了django-celery默认的数据库调度模型,任务执行周期都被存在默认指定的orm数据库中．</p><p>  CELERYBEAT_SCHEDULE：设置定时的时间配置， 可以精确到秒，分钟，小时，天，周等。</p><h3 id="（3）创建应用实例"><a href="#（3）创建应用实例" class="headerlink" title="（3）创建应用实例"></a>（3）创建应用实例</h3><p>​在主工程目录添加celery.py， 添加自动检索django工程tasks任务</p><p>​vim  artproject/celery.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># encoding: utf-8  </span><br><span class="line">#目的是拒绝隐士引入，celery.py和celery冲突。</span><br><span class="line">from __future__ import absolute_import,unicode_literals </span><br><span class="line">import os</span><br><span class="line">from celery import Celery</span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line"># 设置环境变量</span><br><span class="line">os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;artproject.settings&quot;)</span><br><span class="line"></span><br><span class="line">#创建celery应用</span><br><span class="line">app = Celery(&apos;art_project&apos;)</span><br><span class="line">app.config_from_object(&apos;django.conf:settings&apos;)</span><br><span class="line"></span><br><span class="line">#如果在工程的应用中创建了tasks.py模块，那么Celery应用就会自动去检索创建的任务。比如你添加了一个任#务，在django中会实时地检索出来。</span><br><span class="line">app.autodiscover_tasks(lambda :settings.INSTALLED_APPS)</span><br></pre></td></tr></table></figure><h3 id="4-创建任务-tasks"><a href="#4-创建任务-tasks" class="headerlink" title="(4) 创建任务 tasks"></a>(4) 创建任务 tasks</h3><p>每个任务本质上就是一个函数，在tasks.py中，写入你想要执行的函数即可。</p><p>在应用art中添加我们需要提供的异步服务和定时服务 </p><p> vim art/tasks.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># encoding: utf-8  </span><br><span class="line">from __future__ import absolute_import</span><br><span class="line">import time</span><br><span class="line">from django.core.mail import send_mail</span><br><span class="line">from celery.utils.log import get_task_logger</span><br><span class="line">from artproject.celery import app</span><br><span class="line"></span><br><span class="line">from art.utils.send_mail import pack_html, send_email</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def tsend_email():</span><br><span class="line">   url = &quot;http://1000phone.com&quot;</span><br><span class="line">   receiver = &apos;diyuhuan@1000phone.com&apos;</span><br><span class="line">   content = pack_html(receiver, url)</span><br><span class="line">   # content = &apos;this is email content.&apos;</span><br><span class="line">   send_email(receiver, content)</span><br><span class="line">   print(&apos;send email ok!&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def add(x, y):</span><br><span class="line">   return x+y</span><br></pre></td></tr></table></figure><p>上述我们把异步处理任务add和定时器任务tsend_email都放在了tasks.py 中</p><h3 id="（5）迁移生成celery需要的数据表"><a href="#（5）迁移生成celery需要的数据表" class="headerlink" title="（5）迁移生成celery需要的数据表"></a>（5）迁移生成celery需要的数据表</h3><pre><code>python   manage.py   migrate</code></pre><p>此时数据库表结构多出了几个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">celery_taskmeta            |</span><br><span class="line">| celery_tasksetmeta         |</span><br><span class="line">| djcelery_crontabschedule   |</span><br><span class="line">| djcelery_intervalschedule  |</span><br><span class="line">| djcelery_periodictask      |</span><br><span class="line">| djcelery_periodictasks     |</span><br><span class="line">| djcelery_taskstate         |</span><br><span class="line">| djcelery_workerstate</span><br></pre></td></tr></table></figure><h2 id="3-启动服务，测试"><a href="#3-启动服务，测试" class="headerlink" title="3.启动服务，测试"></a>3.启动服务，测试</h2><p>我们可以采用 python manage.py  help  发现多出了 celery 相关选项。 </p><h3 id="（1）启动django-celery-服务"><a href="#（1）启动django-celery-服务" class="headerlink" title="（1）启动django celery 服务"></a>（1）启动django celery 服务</h3><p>启动服务：</p><pre><code>python manage.py  celery   worker    --loglevel=info</code></pre><p>此时异步处理和定时处理服务都已经启动了</p><h3 id="（2）web端接口触发异步任务处理"><a href="#（2）web端接口触发异步任务处理" class="headerlink" title="（2）web端接口触发异步任务处理"></a>（2）web端接口触发异步任务处理</h3><p>我们在web端加入一个入口，触发异步任务处理add函数 </p><p>在应用art的urls.py 中加入如下对应关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from art.views import add_handler</span><br><span class="line"></span><br><span class="line">url(r&apos;^add&apos;, add_handler),</span><br></pre></td></tr></table></figure><p>art/views.py 中加入处理逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def add_handler(request):</span><br><span class="line">   x = request.GET.get(&apos;x&apos;, &apos;1&apos;)</span><br><span class="line">   y = request.GET.get(&apos;y&apos;, &apos;1&apos;)</span><br><span class="line">   from .tasks import add</span><br><span class="line">   add.delay(int(x), int(y))</span><br><span class="line">   res = &#123;&apos;code&apos;:200, &apos;message&apos;:&apos;ok&apos;, &apos;data&apos;:[&#123;&apos;x&apos;:x, &apos;y&apos;:y&#125;]&#125;</span><br><span class="line">   return HttpResponse(json.dumps(res))</span><br></pre></td></tr></table></figure><p>启动web服务，通过url传入的参数，通过handler的add.delay(x, y)计算并存入mysql</p><p><a href="http://127.0.0.1:8000/art/add?x=188&amp;y=22" target="_blank" rel="noopener">http://127.0.0.1:8000/art/add?x=188&amp;y=22</a></p><h3 id="4-测试定时器，发送邮件"><a href="#4-测试定时器，发送邮件" class="headerlink" title="(4)测试定时器，发送邮件"></a>(4)测试定时器，发送邮件</h3><p>在终端输入  python manage.py celerybeat -l info</p><p>会自动触发每隔30s执行一次tsend_email定时器函数，发送邮件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CELERYBEAT_SCHEDULE = &#123;    #定时器策略</span><br><span class="line">    #定时任务一：　每隔30s运行一次</span><br><span class="line">    u&apos;测试定时器1&apos;: &#123;</span><br><span class="line">        &quot;task&quot;: &quot;art.tasks.tsend_email&quot;,</span><br><span class="line">        #&quot;schedule&quot;: crontab(minute=&apos;*/2&apos;),  # or &apos;schedule&apos;: timedelta(seconds=3),</span><br><span class="line">        &quot;schedule&quot;:timedelta(seconds=30),</span><br><span class="line">        &quot;args&quot;: (),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体发送邮件服务程序见下面的第4节</p><h2 id="4-邮件发送服务"><a href="#4-邮件发送服务" class="headerlink" title="4.邮件发送服务"></a>4.邮件发送服务</h2><p>项目中经常会有定时发送邮件的情形，比如发送数据报告，发送异常服务报告等。</p><p>可以编辑文件 art/utils/send_mail.py, 内容编辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">#written by diyuhuan</span><br><span class="line">#发送邮件(wd_email_check123账号用于内部测试使用，不要用于其他用途)</span><br><span class="line"></span><br><span class="line">import smtplib  </span><br><span class="line">from email.mime.multipart import MIMEMultipart  </span><br><span class="line">from email.mime.text import MIMEText  </span><br><span class="line">from email.mime.image import MIMEImage </span><br><span class="line">from email.header import Header</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">sender = &apos;wd_email_check123@163.com&apos;  </span><br><span class="line">subject = u&apos;api开放平台邮箱验证&apos;</span><br><span class="line">smtpserver = &apos;smtp.163.com&apos;</span><br><span class="line">username = &apos;wd_email_check123&apos;</span><br><span class="line">password = &apos;wandacheck1234&apos;</span><br><span class="line">mail_postfix=&quot;163.com&quot;</span><br><span class="line"></span><br><span class="line">def send_email(receiver, content):</span><br><span class="line">    try:</span><br><span class="line">        me = username+&quot;&lt;&quot;+username+&quot;@&quot;+mail_postfix+&quot;&gt;&quot;</span><br><span class="line">        msg = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;)</span><br><span class="line">        msg[&apos;Subject&apos;] = subject</span><br><span class="line">        msg[&apos;From&apos;] = sender</span><br><span class="line">        msg[&apos;To&apos;] = receiver</span><br><span class="line">        smtp = smtplib.SMTP()  </span><br><span class="line">        smtp.connect(smtpserver)  </span><br><span class="line">        smtp.login(username, password)</span><br><span class="line">        smtp.sendmail(sender, receiver, msg.as_string())  </span><br><span class="line">        smtp.quit()</span><br><span class="line">        return True</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&apos;send_email has error with : &apos; + str(e))</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pack_html(receiver, url):</span><br><span class="line">    html_content = u&quot;&lt;html&gt;&lt;div&gt;尊敬的用户&lt;font color=&apos;#0066FF&apos;&gt;%s&lt;/font&gt; 您好！&lt;/div&gt;&lt;br&gt;&quot; \</span><br><span class="line">                   &quot;&lt;div&gt;感谢您关注我们的平台 ，我们将为您提供最贴心的服务，祝您购物愉快。&lt;/div&gt;&lt;br&gt;&quot; \</span><br><span class="line">                   &quot;&lt;div&gt;点击以下链接，即可完成邮箱安全验证：&lt;/div&gt;&lt;br&gt;&quot;  \</span><br><span class="line">                   &quot;&lt;div&gt;&lt;a href=&apos;%s&apos;&gt;%s&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&quot;  \</span><br><span class="line">                   &quot;&lt;div&gt;为保障您的帐号安全，请在24小时内点击该链接; &lt;/div&gt;&lt;br&gt;&quot; \</span><br><span class="line">                   &quot;&lt;div&gt;若您没有申请过验证邮箱 ，请您忽略此邮件，由此给您带来的不便请谅解。&lt;/div&gt;&quot; \</span><br><span class="line">                   &quot;&lt;/html&gt;&quot; % (receiver, url, url)</span><br><span class="line">    html_content = html_content</span><br><span class="line">    return html_content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    url = &quot;http://1000phone.com&quot;</span><br><span class="line">    receiver = &apos;diyuhuan@1000phone.com&apos;</span><br><span class="line">    #content = pack_html(receiver, url)</span><br><span class="line">    content = &apos;this is email content. at %s.&apos;%int(time.time())</span><br><span class="line">    send_email(receiver,  content)</span><br></pre></td></tr></table></figure><p>至此，在celery ui界面可以看到两类，定时器处理和异步处理。</p><h2 id="5-启动flower服务"><a href="#5-启动flower服务" class="headerlink" title="5.启动flower服务"></a>5.启动flower服务</h2><pre><code>python manager celery flower</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Django集成Celery到项目&quot;&gt;&lt;a href=&quot;#Django集成Celery到项目&quot; class=&quot;headerlink&quot; title=&quot;Django集成Celery到项目&quot;&gt;&lt;/a&gt;Django集成Celery到项目&lt;/h2&gt;&lt;p&gt;将celery集成到
      
    
    </summary>
    
      <category term="django" scheme="http://www.baidu.com/categories/django/"/>
    
    
      <category term="django" scheme="http://www.baidu.com/tags/django/"/>
    
      <category term="celery" scheme="http://www.baidu.com/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>django中的日志处理</title>
    <link href="http://www.baidu.com/2019/04/18/django_logging/"/>
    <id>http://www.baidu.com/2019/04/18/django_logging/</id>
    <published>2019-04-17T19:22:43.000Z</published>
    <updated>2019-05-05T11:56:10.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Django中加入日志功能"><a href="#1-Django中加入日志功能" class="headerlink" title="1  Django中加入日志功能"></a>1  Django中加入日志功能</h2><p>Django 中使用python的 logging 模块记录log，在 Django 中使用 Django 提供的配制方法。就是在 settings 中通过变量 LOGGING，LOGGING 是一个字典，典型的配置如下：</p><p>​logging模块为应用程序提供了灵活的手段记录事件、错误、警告和调试信息。对这些信息可以进行收集、筛选、写入文件、发送给系统日志等操作，甚至还可以通过网络发送给远程计算机。</p><h3 id="（1）日志记录级别"><a href="#（1）日志记录级别" class="headerlink" title="（1）日志记录级别"></a>（1）日志记录级别</h3><p>​logging模块的重点在于生成和处理日志消息。每条消息由一些文本和指示其严重性的相关级别组成。级别包含符号名称和数字值。</p><table><thead><tr><th>级别</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>CRITICAL/FATAL</td><td>50</td><td>关键错误/消息</td></tr><tr><td>ERROR</td><td>40</td><td>错误</td></tr><tr><td>WARNING</td><td>30</td><td>警告消息</td></tr><tr><td>INFO</td><td>20</td><td>通知消息</td></tr><tr><td>DEBUG</td><td>10</td><td>调试</td></tr><tr><td>NOTSET</td><td>0</td><td>无级别</td></tr></tbody></table><h3 id="（2）记录器（日志对象-logging-getLogger-）-默认的root记录器"><a href="#（2）记录器（日志对象-logging-getLogger-）-默认的root记录器" class="headerlink" title="（2）记录器（日志对象-logging.getLogger()）-默认的root记录器"></a>（2）记录器（日志对象-logging.getLogger()）-默认的root记录器</h3><p>​记录器负责管理日志消息的默认行为，包括日志记录级别、输出目标位置、消息格式以及其它基本细节。</p><p>如下是处理器Handler关键的参数：</p><table><thead><tr><th>关键字参数</th><th>描述</th></tr></thead><tbody><tr><td>filename</td><td>将日志消息附加到指定文件名的文件</td></tr><tr><td>filemode</td><td>指定用于打开文件模式</td></tr><tr><td>format</td><td>用于生成日志消息的格式字符串</td></tr><tr><td>datefmt</td><td>用于输出日期和时间的格式字符串</td></tr><tr><td>level</td><td>设置记录器的级别</td></tr><tr><td>stream</td><td>提供打开的文件，用于把日志消息发送到文件。</td></tr></tbody></table><h3 id="（3）format-日志消息格式"><a href="#（3）format-日志消息格式" class="headerlink" title="（3）format 日志消息格式"></a>（3）format 日志消息格式</h3><p>​e.g.  ‘%(asctime)s  %(module)s  %(level)s  %(lineno)d’</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%(name)s</td><td>记录器的名称, 默认为root</td></tr><tr><td>%(levelno)s</td><td>数字形式的日志记录级别</td></tr><tr><td>%(levelname)s</td><td>日志记录级别的文本名称</td></tr><tr><td>%(filename)s</td><td>执行日志记录调用的源文件的文件名称</td></tr><tr><td>%(pathname)s</td><td>执行日志记录调用的源文件的路径名称</td></tr><tr><td>%(funcName)s</td><td>执行日志记录调用的函数名称</td></tr><tr><td>%(module)s</td><td>执行日志记录调用的模块名称</td></tr><tr><td>%(lineno)s</td><td>执行日志记录调用的行号</td></tr><tr><td>%(created)s</td><td>执行日志记录的时间</td></tr><tr><td>%(asctime)s</td><td>日期和时间</td></tr><tr><td>%(msecs)s</td><td>毫秒部分</td></tr><tr><td>%(thread)d</td><td>线程ID</td></tr><tr><td>%(threadName)s</td><td>线程名称</td></tr><tr><td>%(process)d</td><td>进程ID</td></tr><tr><td>%(message)s</td><td>记录的消息</td></tr></tbody></table><h3 id="（4）内置处理器"><a href="#（4）内置处理器" class="headerlink" title="（4）内置处理器"></a>（4）内置处理器</h3><p>​    logging模块提供了一些处理器，可以通过各种方式处理日志消息。使用addHandler()方法将这些处理器添加给Logger对象。另外还可以为每个处理器配置它自己的筛选和级别。</p><p>​      handlers.DatagramHandler(host，port):发送日志消息给位于制定host和port上的UDP服务器。</p><p>​      * handlers.FileHandler(filename): 将日志消息写入文件filename。</p><p>​      handlers.HTTPHandler(host, url):使用HTTP的GET或POST方法将日志消息上传到一台HTTP 服务器。</p><p>​      * handlers.RotatingFileHandler(filename):将日志消息写入文件filename。如果文件的大小超出maxBytes制定的值，那么它将被备份为filename1。</p><p>​    由于内置处理器还有很多，如果想更深入了解。可以查看官方手册。</p><h3 id="（5）python的日志简单地用法"><a href="#（5）python的日志简单地用法" class="headerlink" title="（5）python的日志简单地用法"></a>（5）python的日志简单地用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置日志等级</span></span><br><span class="line">logging.getLogger().setLevel(logging.INFO)</span><br><span class="line">formatter = <span class="string">'%(asctime)s: %(filename)s/%(funcName)s at %(lineno)s-&gt;%(message)s'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置日志的信息，filename 要指定日志输出的文件名</span></span><br><span class="line">logging.basicConfig(format=formatter,</span><br><span class="line">                    datefmt=<span class="string">'%Y-%m-%d %H:%M:%S'</span>,</span><br><span class="line">                    filename=<span class="string">'art.log'</span>,</span><br><span class="line">                    filemode=<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">logging.warning(<span class="string">'--当前页面要被缓存5秒---'</span>)</span><br></pre></td></tr></table></figure><h2 id="2-Django中使用日志"><a href="#2-Django中使用日志" class="headerlink" title="2  Django中使用日志"></a>2  Django中使用日志</h2><p>在Django的配置文件settings.py 中加入如下LOGGING配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Django Logging  BEGIN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#LOGGING_DIR 日志文件存放目录</span><br><span class="line">LOGGING_DIR = &quot;/home/xxt/logs&quot;</span><br><span class="line">if not os.path.exists(LOGGING_DIR):</span><br><span class="line">    os.mkdir(LOGGING_DIR)</span><br><span class="line"></span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">LOGGING = &#123;</span><br><span class="line">    &apos;version&apos;: 1,</span><br><span class="line">    &apos;disable_existing_loggers&apos;: False,</span><br><span class="line">    &apos;formatters&apos;: &#123;</span><br><span class="line">        &apos;standard&apos;: &#123;</span><br><span class="line">            &apos;format&apos;: &apos;[%(levelname)s][%(asctime)s][%(filename)s][%(funcName)s][%(lineno)d] &gt; %(message)s&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;simple&apos;: &#123;</span><br><span class="line">            &apos;format&apos;: &apos;[%(levelname)s]&gt; %(message)s&apos;,</span><br><span class="line">            &apos;datefmt&apos;: &apos;%Y-%m-%d %H:%M:%S&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;filters&apos;: &#123;</span><br><span class="line">        &apos;require_debug_true&apos;: &#123;</span><br><span class="line">            &apos;()&apos;: &apos;django.utils.log.RequireDebugTrue&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;handlers&apos;: &#123;</span><br><span class="line">        &apos;console&apos;: &#123;</span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;filters&apos;: [&apos;require_debug_true&apos;],</span><br><span class="line">            &apos;class&apos;: &apos;logging.StreamHandler&apos;,</span><br><span class="line">            &apos;formatter&apos;: &apos;simple&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;file_handler&apos;: &#123;</span><br><span class="line">             &apos;level&apos;: &apos;INFO&apos;,</span><br><span class="line">             &apos;class&apos;: &apos;logging.handlers.TimedRotatingFileHandler&apos;,</span><br><span class="line">             &apos;filename&apos;: &apos;%s/django.log&apos; % LOGGING_DIR,</span><br><span class="line">             &apos;formatter&apos;:&apos;standard&apos;,</span><br><span class="line">             &apos;encoding&apos;: &apos;utf-8&apos;</span><br><span class="line">        &#125;, # 用于文件输出</span><br><span class="line">        &apos;mail_admins&apos;: &#123;</span><br><span class="line">            &apos;level&apos;: &apos;ERROR&apos;,</span><br><span class="line">            &apos;class&apos;: &apos;django.utils.log.AdminEmailHandler&apos;,</span><br><span class="line">             &apos;formatter&apos;:&apos;standard&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;loggers&apos;: &#123;</span><br><span class="line">        &apos;mdjango&apos;: &#123;</span><br><span class="line">            &apos;handlers&apos;: [&apos;console&apos;,&apos;file_handler&apos;],</span><br><span class="line">            &apos;level&apos;:&apos;DEBUG&apos;,</span><br><span class="line">            &apos;propagate&apos;: True,</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;django.request&apos;: &#123;</span><br><span class="line">            &apos;handlers&apos;: [&apos;mail_admins&apos;],</span><br><span class="line">            &apos;level&apos;: &apos;ERROR&apos;,</span><br><span class="line">            &apos;propagate&apos;: False,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(&quot;mdjango&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Django Logging  END</span><br></pre></td></tr></table></figure><p>最新日志内容存入：  django.log</p><p>前一天：django.log.2018-05-29</p><p>前前一天：django.log.2018-05-28</p><p>django.log.2018-05-22</p><p>在具体的业务逻辑代码中加入日志记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from Project.settings import  logger</span><br><span class="line">logger.info(&quot;IndexHandler request Handler begin&quot;)</span><br><span class="line">logger.debug(&apos;query total:&apos; + str(total))</span><br></pre></td></tr></table></figure><p>观察日志打印情况。</p><p>一般python使用日志功能（非django框架）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">def logging_init():</span><br><span class="line">   app_name = &quot;AppName&quot;</span><br><span class="line">   log_file_name = &quot;myapp_test.log&quot;</span><br><span class="line">   logger = logging.getLogger(app_name)</span><br><span class="line">   format_str = &quot;[%(asctime)s][%(levelname)s]&gt; %(message)s&quot;</span><br><span class="line">   formatter = logging.Formatter(format_str)</span><br><span class="line">   file_handler = logging.FileHandler(log_file_name)</span><br><span class="line">   file_handler.setFormatter(formatter)</span><br><span class="line">   logger.addHandler(file_handler)</span><br><span class="line">   logger.setLevel(logging.INFO)</span><br><span class="line">   return logger</span><br></pre></td></tr></table></figure><p>单例模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">   _instance = None</span><br><span class="line"></span><br><span class="line">   def __new__(cls, *args, **kwargs):</span><br><span class="line">      if not cls._instance:</span><br><span class="line">         cls._instance = super(Singleton, cls).__new__(cls,</span><br><span class="line">                                    *args, **kwargs)</span><br><span class="line">      return cls._instance</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">app_name = &quot;appName&quot;</span><br><span class="line">log_file = &quot;test.log&quot;</span><br><span class="line"></span><br><span class="line">class SingletonLogger(Singleton):</span><br><span class="line"></span><br><span class="line">   def __init__(self):</span><br><span class="line">      super(SingletonLogger, self).__init__()</span><br><span class="line">      self.logger = logging.getLogger(app_name)</span><br><span class="line">      format_str = &quot;[%(asctime)s][%(levelname)s]&gt; %(message)s&quot;</span><br><span class="line">      formatter = logging.Formatter(format_str)</span><br><span class="line">      file_handler = logging.FileHandler(log_file)</span><br><span class="line">      file_handler.setFormatter(formatter)</span><br><span class="line">      self.logger.addHandler(file_handler)</span><br><span class="line">      self.logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">   def debug(self, data):</span><br><span class="line">      self.logger.debug(data)</span><br><span class="line"></span><br><span class="line">   def info(self, data):</span><br><span class="line">      self.logger.info(data)</span><br><span class="line"></span><br><span class="line">   def warning(self, data):</span><br><span class="line">      self.logger.warning(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   def error(self, data):</span><br><span class="line">      self.logger.error(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_log():</span><br><span class="line">   logger = SingletonLogger()</span><br><span class="line">   #output the log msg</span><br><span class="line">   logger.debug(&quot;this is the debug message&quot;)</span><br><span class="line">   logger.info(&quot;this is the info message&quot;)</span><br><span class="line">   logger.warning(&quot;this is the warning message&quot;)</span><br><span class="line">   logger.error(&quot;this is the error message&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Django中加入日志功能&quot;&gt;&lt;a href=&quot;#1-Django中加入日志功能&quot; class=&quot;headerlink&quot; title=&quot;1  Django中加入日志功能&quot;&gt;&lt;/a&gt;1  Django中加入日志功能&lt;/h2&gt;&lt;p&gt;Django 中使用python
      
    
    </summary>
    
      <category term="django" scheme="http://www.baidu.com/categories/django/"/>
    
    
      <category term="django" scheme="http://www.baidu.com/tags/django/"/>
    
      <category term="log" scheme="http://www.baidu.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>plan</title>
    <link href="http://www.baidu.com/2019/04/05/plan/"/>
    <id>http://www.baidu.com/2019/04/05/plan/</id>
    <published>2019-04-05T09:36:34.000Z</published>
    <updated>2019-05-05T14:02:36.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>Mysql / Mongodb / Redis<br>Tomact  Nginx<br>Kubernetes / Docker<br>python shell<br>Ansible/ Puppet / SaltStack / Fabric<br>Zabbix/ Nagios / Cacti / Grafana / Prometheus / ELK /<br>Kafka</p><p>jenkins / gitlab /</p><p>Lvs / Haproxy<br>LAMP / LNMP/</p><p>DAS/SNA/NAS/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;auto&quot;&gt;&lt;a href=&quot;#auto&quot; class=&quot;headerlink&quot; title=&quot;auto&quot;&gt;&lt;/a&gt;auto&lt;/h2&gt;&lt;p&gt;Mysql / Mongodb / Redis&lt;br&gt;Tomact  Nginx&lt;br&gt;Kubernetes / Docke
      
    
    </summary>
    
      <category term="plan other" scheme="http://www.baidu.com/categories/plan-other/"/>
    
    
      <category term="plan" scheme="http://www.baidu.com/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>hexo</title>
    <link href="http://www.baidu.com/2019/04/05/hexo/"/>
    <id>http://www.baidu.com/2019/04/05/hexo/</id>
    <published>2019-04-05T09:36:34.000Z</published>
    <updated>2019-05-21T00:30:37.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><table><thead><tr><th>文件/文件夹</th><th>说明</th></tr></thead><tbody><tr><td>_config.yml</td><td>配置文件</td></tr><tr><td>public</td><td>生成的静态文件，这个目录最终会发布到服务器</td></tr><tr><td>scaffolds</td><td>一些通用的markdown模板</td></tr><tr><td>source</td><td>编写的markdown文件，_drafts草稿文件，_posts发布的文章</td></tr><tr><td>themes</td><td>博客的模板</td></tr></tbody></table><p>常用命令</p><pre><code>hexo new &quot;postName&quot;hexo new page &quot;pageName&quot;hexo server</code></pre><hr><pre><code>npm install hexo-cli -ghexo init blogcd blognpm installhexo server</code></pre><p>创建一篇新的文章</p><pre><code>hexo new [layout] &lt;title&gt;</code></pre><p>hexo有三种默认的布局：post,page,draft他们分别对应的路径如下<br>|布局|路径|<br>|—|—|<br>|post|source/_posts|<br>|page|source|<br>|draft|source/_drafts|</p><h2 id="提交到github"><a href="#提交到github" class="headerlink" title="提交到github"></a>提交到github</h2><p>安装git插件</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>git的配置，修改_config.yml文件</p><pre><code>deploy:    type: git    repository: git@github.com:love-fengyuan/love-fengyuan.github.io.git    branch: master </code></pre><p>将代码push到github：</p><pre><code>hexo deploy</code></pre><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>执行deploy命令了，但是代码未上传？</p><pre><code>先执行hexo generate命令，生成静态文件了，再执行hexo deploy上传，上传是只会上传public中生成的文件。</code></pre><p>修改了模板，但是没有生效？</p><pre><code>修改了模板没有生效，建议先“hexo clean”，然后在“hexo generate”，只执行hexo generate，可能模板后者静态文件不会替换。</code></pre><h3 id="第二篇博客"><a href="#第二篇博客" class="headerlink" title="第二篇博客"></a>第二篇博客</h3><ol><li>hexo new title</li><li>修改显示路径，使用start路径来编辑它（如果是\斜杠需换成/斜杠）</li><li>hexo generate</li><li>hexo deploy</li><li>查看博客</li></ol><h2 id="插入图片视频"><a href="#插入图片视频" class="headerlink" title="插入图片视频"></a>插入图片视频</h2><p>插入图片</p><pre><code>![k8sss](test/k8s_jg.png)</code></pre><p>插入视频</p><pre><code>&lt;video href=&apos;test/roam_1.mp4&apos; type=&apos;video/mp4&apos; controls=&apos;controls&apos;  width=&apos;100%&apos; height=&apos;100%&apos;&gt;love&lt;/video&gt;{% raw %}    <video src="test/6a0250dbd55daf505801cf877c370626.mp4" type="video/mp4" controls="controls" width="100%" height="100%"></video>    {% endraw%}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><pre><code>官网：https://hexo.io/zh-cn/https://www.jianshu.com/p/da491b249aeehttps://www.jianshu.com/p/a7cc54797ecc</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件/文件夹&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;
      
    
    </summary>
    
      <category term="hexo" scheme="http://www.baidu.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.baidu.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ansible</title>
    <link href="http://www.baidu.com/2019/03/10/ansible/"/>
    <id>http://www.baidu.com/2019/03/10/ansible/</id>
    <published>2019-03-10T15:06:52.000Z</published>
    <updated>2019-05-05T07:25:07.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h1><h2 id="Ansible-基础"><a href="#Ansible-基础" class="headerlink" title="Ansible 基础"></a>Ansible 基础</h2><ol><li>ANSIBLE_CONFIG  环境变量，可以定义配置文件的位置</li><li>./ansible.cfg    存在于当前工作目录</li><li>~/.ansible.cfg   存在于当前用户家目录</li><li>/etc/ansible/ansible.cfg 默认目录</li></ol><h2 id="Ansible命令"><a href="#Ansible命令" class="headerlink" title="Ansible命令"></a>Ansible命令</h2><p>主机要求：<br>windows除外</p><p>配置语言：<br>    yaml，json<br>只有server</p><p>role:<br>ansible 可以重复使用的</p><p>Ansible:</p><p><a href="https://github.com/ansible/ansible" target="_blank" rel="noopener">https://github.com/ansible/ansible</a></p><p>从release下载安装包</p><p>需要pip安装包的依赖</p><p>log：</p><p><a href="https://www.cnblogs.com/xielisen/p/6817807.html" target="_blank" rel="noopener">https://www.cnblogs.com/xielisen/p/6817807.html</a></p><p>查看文件个数：<br>ls -l | grep ‘^-‘ | wc -l </p><p>##################################马哥 Ansible</p><p>文件传输<br>命令执行：应用部署，配置管理，任务流编排</p><p>企业应用场景：<br>开发，测试，发布，生产，灰度环境（基于主机，用户，地区）</p><p>vie0 修改主机ip</p><p>ansible -m ping<br>m:模块<br>ansible 127.0.0.1 -m ping</p><p>在 /etc/ansible/hosts中配置主机清单</p><p>测试网络通讯;</p><pre><code>ansible 192.168.1.101 -m ping -k </code></pre><p>输入口令（密码）<br>k: 密码认证<br>建议基于key验证</p><pre><code>etc/ssh/sshd_config  ansible all -m ping  </code></pre><p>all: 代表主机清单的所有主机</p><h2 id="ansible-cfg"><a href="#ansible-cfg" class="headerlink" title="ansible.cfg"></a>ansible.cfg</h2><p>ansible.cfg</p><pre><code>forks=5     并发执行5</code></pre><p>ansible-doc:显示模块命令</p><p>ansible websevers –list-hosts</p><p>ansible all –list-host</p><p>ansible debserver -m ping -u wang -k    以wang的身份去连接</p><p>ansible debserver -m command -a ‘ls /root’ -u wang -k -b -K<br>以wang身份连接，切换到root用户权限，默认为root -K root口令</p><p>usermod -a -G wheel wang 将wang加入到组</p><p>K的口令;<br>sudo中：取消下面一行的注释：<br>%wheel ALL=(ALL)    NOPASSWD:ALL</p><p>基于key验证</p><pre><code>ssh-keygenssh-copy-id 192.168.80.101ssh-copy-id 192.168.80.102.......</code></pre><p>&amp; linux中表示后台执行</p><p>ansible all -m command -a “sleep 10”<br>休眠10s</p><p>command:</p><p>ansible all -a ‘ls /data’</p><p>ansible all -a ‘df -h’</p><p>ansible-doc command</p><p>creates 存在不执行</p><p>ansible all -a ‘removes=/etc/fs cat /etc/fstab’</p><p>removes 不存在不执行</p><p>ansible all -a ‘creates=/etc/fs cat /etc/fstab’</p><p>chdir  切换文件夹</p><p>ansible all -a ‘chdir=/root ls’</p><p>ansible 192.168.80.101 -a ‘/data/test.sh’</p><p>执行该主机上/data/test.sh</p><p>注： 注意规范 #！/bin/bash</p><p>创建账号：</p><pre><code>ansible all -a &apos;useradd test1&apos;</code></pre><p>查询：</p><pre><code>ansible all -a &apos;getent passwd test1&apos;</code></pre><p>command 命令对管道，重定向,变量 特殊符号支持有问题，建议shell</p><p>shell：</p><pre><code>ansible all -m shell -a &apos;echo $HOSTNAME&apos;</code></pre><p>更改口令:</p><pre><code>ansible all -m shell -a &apos;echo magedu|passwd --stdin test1&apos;</code></pre><p>script：</p><p>chmod +x test.sh</p><p>ansible all -m script -a ‘/root/ansible/test.sh’<br>在所有主机上执行test.sh</p><p>ansible all -a ‘getenforce’</p><p>cp /etc/sysconfig/selinux &gt;<br>vim selinux </p><p>copy:<br>ansible-doc -s copy</p><p>ansible all -m copy -a ‘src=/root/ansible/selinux dest=/etc/selinux/config backup=yes’<br>文件复制</p><p>ansible all -m shell -a ‘getenforce’</p><p>ansible all -m copy -a ‘src=/etc/shadow dest=/data mode=000 owner=root’</p><p>ansible all -m copy -a ‘content=”hello\n thanks \n “ dest=/data/f2’<br>直接写内容生成文件</p><p>fetch：<br>从客户端去文件到服务器端，与copy相反</p><p>ansible all -m fetch -a ‘src=/var/log/messages dest=/data’<br>从远程主机抓取log/message,到服务器，仅限单个文件</p><p>ansible all -m shell -a ‘tar jcf log.tar.xz /var/log/*.log’</p><p>包的加压与解压<br>archive<br>unarchive</p><p>file：</p><p>ansible all -m file -a ‘name=/data/f3 state=touch’  创建文件</p><p>ansible all -m file -a ‘name=/data/f3 state=absent’ 删除文件</p><p>ansible all -a ‘ls -l /data’</p><p>ansible all -m file -a ‘name=/data/dir1 state=directory’    创建文件夹，’state=absent’ 删除</p><p>‘src=/etc/fstab dest=/data/fstab.link state=link’   创建软连接</p><p>‘dest=/data/fstab.link state=absent’    删除软连接</p><p>‘dest=/data/* state=absent’ 删除所有文件</p><p>‘dest=/data/ state=absent’  删除文件夹</p><p>不能删除挂载点上的</p><p>ansible 192.168.80.101 -m hostname -a ‘name=new_name’ 修改主机名</p><p>cron：</p><p>ansible all -m cron -a ‘minute=* weekday=1,3,5 job=”/usr/bin/wall FBI warning” name=warningcron’ 创建定时报警任务，写入crontab</p><p>ansible all -m cron -a ‘disabled=true job=”/usr/bin/wall FBI warning” name=warningcron’ 禁用此任务，必须加name</p><p>‘job=”/usr/bin/wall FBI warning” name=warningcron state=absent’ 删除</p><p>yum<br>/etc/yum.repos/base.repo yum仓库配置</p><p>ansible all -m yum -a ‘name=vsftpd’<br>安装<br>多个软件用’,’隔开</p><p>ansible all -m yun -a ‘list=instealled’ 安装过的列表</p><p>‘name=vsftpd state=removed’卸载</p><p>‘name=vsftpd state=absent’</p><p>‘rpm -q vsftpd’ 查找是否卸载</p><p>安装下载好的软件；<br>ansible all -m copy -a ‘src=/data/softname dest=/root/‘</p><p>ansible all -a ‘ls /root/‘</p><p>ansbile all -m yum -a ‘name=/root/softname’</p><p>disable_gpg_check=yes 忽略，禁用</p><p>‘name=dstat update_cache=yes’ 更新缓存</p><p>services:</p><p>ansible all -m services -a ‘name=vsftpd state=started enabled=yes’<br>启动服务，同时设为开机启动  </p><p>user:</p><p>ansible all -m user -a ‘name=nginx shell=/sbin/nologin system=yes home=/var/nginx groups=root,bin uid=80 comment=”nginx service”‘</p><p>创建账号</p><p>ansible all -m user -a ‘name=nginx state=absent remove=yes’ 删除账号，删除home目录</p><p>group:</p><p>ansible all -m group -a ‘name=nginx system=yes gid=80’</p><p>ansible all -a ‘getent group nginx’</p><p>ansible -m group -a ‘name=nginx state=absent’  删除</p><p>ansible-galaxy:</p><p>ansible-galaxy install geerlingguy.nginx</p><p>yml/yaml:</p><p>注意缩进，格式</p><pre><code>----hosts:webserverremote_user:roottasks:    -name:hello    command：hostname</code></pre><p>ansible-playbook test.yaml</p><p>ansible-vault:<br>ansible-vault encrypt test.yaml     对文件进行加密，避免敏感信息泄露</p><p>需要设置加密口令,再次执行yaml时会报错，</p><p>ansible-vault decrypt test.yaml     解密</p><p>ansible-vault view test.yaml   查看yaml需要输入口令</p><p>ansible-vault rekey test.yaml  修改密码</p><p>ansible-vault create test2.yaml     创建新的playbook文件</p><p>ansible-console:</p><p>交互式：<br>ansible-console</p><p>“root@all (3)[f:5]$ “ 并发数量为5也可以修改forks 10</p><p>cd 192.168.80.135  切换到135主机</p><p>hostname name=node2.magedu.com 修改主机名</p><h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>playbook采用YAMl语言编写</p><p>1.# test yaml 注释<br>2.缩进必须统一</p><pre><code>---- hosts:webserverremote_user:roottasks:    - name:create new file  #描述    file:name=/data/newfile state=touch   模块/命令    - name:create new user    user: name=test2     - name: install httpd    yum:name=httpd    - name:copy conf    copy:src=/etc/conf dest=/etc/conf    - name:start service    service:name=httpd state=started enables=yes</code></pre><p>ansible-playbook -C file.yml    # -C 检查</p><p>ansible all -a ‘getent passwd test2’    #查看test2用户</p><p>ansible all -m shell -a ‘ss -tln | grep :80’    #查看80端口</p><p>ansible all -a ‘getent passwd test2’ –limit 192.168.80.134</p><p>ansibel-playbook file.yml –list</p><p>ansibel-playbook file.yml –list-tasks</p><pre><code>- name:copy a filecopy:src=files/test.py dest=/etc/test.py  #files相对路径，相对于当前目录</code></pre><p>注：文件修改后再次执行copy，不会生效</p><p> 更新配置文件，执行playbook后，并不会生效</p><pre><code>http.yml---- hosts: webserverremote_user:roottasks:    - name:install https package    yum:name-httpd    - name: copy conf file    copy: src=files/httpd.conf dest=/etc/httpd/conf baskup=yes    - name: start service    service: name=httpd state=started enabled=yes</code></pre><p>执行http.yml，修改配置文件后，执行不会重启</p><pre><code>http.yml---- hosts: webserver  remote_user:root  tasks:    - name:install https package    yum:name-httpd    tag:inshttpd    - name: copy conf file    copy: src=files/httpd.conf dest=/etc/httpd/conf baskup=yes    notify:restart service    - name: start service    service: name=httpd state=started enabled=yes    tag:rshttpd  handlers:    - name: restart service      service: name=http state=restarted</code></pre><p>也可以同时触发两个任务</p><p>tags：</p><p>添加标签，可以单独执行标签</p><p>多个动作共用一个标签</p><p>ansible-playbook -t rshttpd httpd.yml</p><p>ansible-playbook -t inshttpd,rshttpd httpd.yml</p><p>setup:</p><p>ansible all -m setup -a ‘filter=ansible_hostname’</p><p>ansible all -m setup -a ‘filter=<em>address</em>‘\</p><p>ansible all -m setup -a ‘filter=ansible_all_ipv4_address’</p><pre><code>app.yml---- hosts: webserverremote_user: roottasks:    - name: install packing    yum: name={{ pkname }}    - name: start service    service: name={{ pkname }} state=started enabled=yes</code></pre><p>ansible-playbook -e ‘pkname=httpd’ app.yml</p><p>pkname 不会写死，灵活定义</p><p>也可以同时装多个包，用逗号隔开</p><p>eg：</p><pre><code>---- hosts:websever  remote_user: root  vars:    - pkname1: httpd    - pkname2: vsftpd  tasks:    - name:install pachage      yum: name={{ pkname1 }}    - name: install package      yum: name={{ pkname2 }}</code></pre><p>定义变量在playbook中，</p><pre><code>hostname.yml:---- hosts: webserver  rempte_user: root  tasks:    - name: set hostname      hostname: name= www{{http_port}}.magedu.com</code></pre><p>hosts：</p><pre><code>[webserver:vars]nodenamw=wwwdomainname=magedu.com</code></pre><p>此处的变量对webserver所有主机有效</p><pre><code>tasks:  - name: set hostname    hostname：name={{nodename}}{{http_port}}.{{domasinname}}</code></pre><p>命令行优先级高于配置文件</p><p>ansible all -m setup<br>ansible all -m setup -a ‘filter=”ansbile_fqdn”‘</p><pre><code>var.yml---- hosts:webserverrenote_use: roottasks:    - name: create a file    file: name=/data/{{ ansible_fqdn }}.log state=touch mode=600 owner=wang</code></pre><p>ansible-playbook -c var.yml</p><p>vars.yml</p><p>var1: httpd<br>var2: vsftpd</p><pre><code>testvars.yml---- hosts: webserver  remote_user: root  vars_file:    - vars.yml  tasks:    - name：install package      yum: name={{ var1 }}    - name: create file      file: name= /data/{{ var2 }}.log state=touch</code></pre><p>template.yml</p><pre><code>---- hosts: webserverremote_user: roottasks:     - name: install package    tum: name=nginx    - name: copy template    template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf    - name start service    service: name=nginx state=started enabled=yes</code></pre><p>ansible all -m shell -a ‘ss -ntpl’  #查看端口</p><p>nginx.conf中修改:</p><p>worker_processes NaN     #cpu个数的2次方</p><p>修改template.yml</p><pre><code>---- hosts: webserverremote_user: roottasks:     - name: install package    tum: name=nginx    - name: copy template    template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf    notify: start service    - name start service    service: name=nginx state=started enabled=yeshandlers:    - name: restart service      service: name=nginx state=restarted</code></pre><p>ansible all -m shell -a ‘ps aux | grep nginx’   #过滤nginx进程</p><p>hosts：也可以写成如下模式</p><p>[webserver]<br>192.168.80.134 http_port=81<br>192.168.80.135 http_port=82</p><p>ansible-playbook -e ‘http_port=99’ testtemp.yml  #修改端口</p><p>优先级：命令行&gt;playbook&gt;主机清单</p><p>ansibel all -m setup -a ‘filte=ansible_os_family’</p><p>‘filter=”<em>distribution</em>“‘</p><p>testitem.yml</p><pre><code>---- hosts: webserverremote_user: roottasks:    - name: create some files      file: name=/data/{{ item }} state=touch      when: ansible_distribution_major_version == &quot;7&quot;      with_items:        - file1        - file2        - file3    - name: install spme package      yum: name={{ item }}      with_items:        - htop        - sl        - hping3</code></pre><p>create_group.yml</p><pre><code>---- hosts: all  remote_user: root  tasks:    - name: create some groups      group: name={{ item }}      when: ansible_distribution_major_version == &quot;7&quot;      with_items:        - g1        - g2         - g3</code></pre><p>创建用户，并加入到组</p><pre><code>---- hosts: all  remote_user: root  tasks:    - name: create some groups      group: name={{ item }}      when: ansible_distribution_major_version == &quot;7&quot;      with_items:        - g1        - g2         - g3    - name:create some users      user: name={{item.name}} group={{item.group}}      with_items:        - { name: &apos;user1&apos;, group: &apos;g1&apos; }        - { name: &apos;user2&apos;, group: &apos;g2&apos; }        - { name: &apos;user3&apos;, group: &apos;g3&apos; }</code></pre><hr><p>for:</p><p>testfor.yml</p><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - 81      - 82      - 83  tasks:    - name: copy conf      template: src=for1.conf.j2 dest=/data/for1.conf</code></pre><p>创建文件：for1.conf.j2</p><pre><code>{% for port in ports %}    server{        listen {{ port }}    }    {% endfor %}</code></pre><hr><p>修改为字典模式：</p><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - listen_port:81      - listen_port:82      - listen_port:83  tasks:    - name: copy conf      template: src=for2.conf.j2 dest=/data/for1.conf   </code></pre><p>for2.conf.j2</p><pre><code>{% for port in ports %}    server{        listen {{ port.listen_port }}    }    {% endfor %}</code></pre><hr><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - web1:        port: 81        name: web1.magedu.com        rootdir: /data/website1      - web2:        port: 83        name: web2.magedu.com        rootdir: /data/website2      - web3:        port: 83        name: web3.magedu.com        rootdir: /data/website3  tasks:    - name: copy conf      template: src=for3.conf.j2 dest=/data/for1.conf </code></pre><p>for3.conf.j22</p><pre><code>{% for p in ports %}    server{        listen {{ p.port }}        servername {{ p.name }}        documentroot {{ p.rootdir }}    }    {% endfor %}</code></pre><hr><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - web1:        port: 81        #name: web1.magedu.com        rootdir: /data/website1      - web2:        port: 83        name: web2.magedu.com        rootdir: /data/website2      - web3:        port: 83        #name: web3.magedu.com        rootdir: /data/website3  tasks:    - name: copy conf      template: src=for4.conf.j2 dest=/data/for4.conf</code></pre><p>for4.conf.j22</p><pre><code>{% for p in ports %}    server{        listen {{ p.port }}    {% if p.name is defined %}        servername {{ p.name }}    {% endif %}        documentroot {{ p.rootdir }}    }    {% endfor %}</code></pre><h2 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h2><p>创建roles文件夹：</p><p>mkdir roles</p><p>mkdir roles/{httpd, mysql, memcache} -pv</p><p>mkdir roles/nginx</p><p>ansible all -m shell -a ‘rpm -q nginx’</p><p>‘getent group nginx’</p><p>‘userdel -f nginx’ 删除用户，组</p><p>cd nginx</p><p>mkdir tasks templates</p><p>cd tasks</p><p>vim group.yml</p><pre><code>- name:create group  group: name=nginx gid=80</code></pre><p>vim user.yml</p><pre><code>- name: create user  user: name=nginx group=nginx system=yes shell=/sbin/nologin uid=80</code></pre><p>vim yum.yml</p><pre><code>- name: install package  yum: name=nginx</code></pre><p>vim start.yml</p><pre><code>- name: start service  service: name=nginx state=started enabled=yes</code></pre><p>vim restart.yml</p><pre><code>- name: restart service  sservice: name=nginx  state=restarted</code></pre><p>templates:</p><p>nginx.conf.j2(nginx.conf重命名为此)</p><p>vim temp.yml</p><pre><code>- name: copy conf  template: src=nginx.conf.j2 dest=/etc/ngiunx/nginx.conf</code></pre><p>vim main.yml</p><pre><code>- include: group.yml- include: user.yml- include: yum.yml- include: temp.yml- include: start.yml</code></pre><p>调用的剧本与roles同级</p><p>vim nginx_role.yml</p><pre><code>- hosts: all  remote_usr: root  roles:    - role: nginx</code></pre><p>ansibel-playbook -c nginx_role.yml</p><hr><p>httpd_roles</p><p>mkdir tasks</p><p>vim user.yml</p><pre><code>- name: create user  user: name=apache system=yes shell=/sbin/nologin</code></pre><p>vim copyfile.yml</p><pre><code>- name: copy file  file: src= dest=</code></pre><hr><p>httpd：</p><p>tasks：</p><p>vim user.yml</p><pre><code>- name: create user  user: name=apache system=yes shell=/sbin/nologin</code></pre><p>vim copyfile.yml</p><pre><code>- name: copy file  copy: src=httpd.conf dest=/data/</code></pre><p>vim main.yml</p><pre><code>- include: user.yml- include: copyfile.yml</code></pre><p>vim httpd_role.yml</p><pre><code>- hosts: all  remote_user: root  roles:    - role: httpd</code></pre><p>在一个角色中，调用另一个角色</p><p>vim some_role.yml</p><pre><code>- hosts: all  remote_user：root  roles:    - role: http    - role: nginx</code></pre><p> 一个角色引用另一个角色中的任务<br>在main.yml中添加一行</p><pre><code>- include: roles/httpd/tasks/copyfileyml</code></pre><p>此处需要注意路径的选择</p><p>ansible.cfg</p><p>当playbook失败的情况下，一个重试文件将会创建，后缀为retry，默认开启此功能</p><p>添加标签：<br>some_role.yml</p><pre><code>---- hosts: all  remote_user: root  roles:    - { role: httpd, tags:[&apos;web&apos;, &apos;httpd&apos;] }    #即属于web，也属于httpd    - { role: nginx, tags:[&apos;web&apos;, &apos;nginx&apos;] }</code></pre><p>ansible-playbook -t web some_role.yml   #只执行标签web</p><p>some_role.yml</p><pre><code>---- hosts: all  remote_user: root  roles:    - { role: httpd, tags:[&apos;web&apos;, &apos;httpd&apos;] }    #即属于web，也属于httpd    - { role: nginx, tags:[&apos;web&apos;, &apos;nginx&apos;] , when: ansible_distribution_major_version == &apos;7&apos;}    # 当版本为7的时候执行</code></pre><hr><p>mkdir app<br>cd app<br>mkdir tasks templates vars handlers files</p><p>task:</p><p>vim group.yml</p><pre><code>- name: create group  group: name=app system=yes gid=123</code></pre><p>vim user.yml</p><pre><code>- name: create user  user: name=app group=app system=yes shell=/sbin/nologin uid=1223</code></pre><p>vim yum.yml</p><pre><code>- name: isntall package  yum: name=httpd</code></pre><p>vim templ.yml</p><pre><code>- name: copy conf  template: src=httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf  notify: restart service</code></pre><hr><p>vars:<br>main.yml    </p><pre><code>username:appgroupname: app</code></pre><hr><p>handlers:<br>vim main.yml</p><pre><code>- name: restart service  service: name=httpd state=restarted</code></pre><hr><p> tasks:<br> vim start.yml</p><pre><code>- name: start service  service: name=httpd state=started enabled=yes</code></pre><p>vim copyfile.yml</p><pre><code>- name: copy config  copy: src=vhosts.conf dest=/etc/httpd/conf.d/ owner=app</code></pre><p>vim main.yml</p><pre><code>- include: group.yml- include: user.yml- include: yum.yml- include: templ.yml- include: copyfile.yml- include: start.yml</code></pre><hr><p>files:<br>touch vhosts.conf</p><hr><p>app_role.yml</p><pre><code>- hosts: all  remote_user: root  roles:    - app</code></pre><p>memcached:</p><p>yum install memcached</p><p>cat /etc/sysconfig/memcached</p><p>cp /etc/sysconfig/memcached templates/memcached.j2<br>修改：<br>CACHESIZE=”NaN“</p><p>vim tasks/yum.yml</p><pre><code>- name: install package  yum: name=memcached</code></pre><p>vim taska/start.yml</p><pre><code>- name: start service  service: name=memcached state=started enabled=yes</code></pre><p>vim /tasks/templ.yml</p><pre><code>- name: copy conf  templates: src=memcached.j2 dest=/etc/sysconfig/memcached</code></pre><p>vim tasks/main.yml</p><pre><code>- include: yum.yml- include: templ.yml- include: start.yml</code></pre><p>vim memcached_role.yml</p><pre><code>- hosts: all  remote_user: root  roles:    - memcached</code></pre><p>ansible-playbook -C memecached_role.yml</p><p>ansible-playbook memcached_role.yml</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ansible&quot;&gt;&lt;a href=&quot;#Ansible&quot; class=&quot;headerlink&quot; title=&quot;Ansible&quot;&gt;&lt;/a&gt;Ansible&lt;/h1&gt;&lt;h2 id=&quot;Ansible-基础&quot;&gt;&lt;a href=&quot;#Ansible-基础&quot; class=&quot;head
      
    
    </summary>
    
      <category term="ansible" scheme="http://www.baidu.com/categories/ansible/"/>
    
    
      <category term="ansible" scheme="http://www.baidu.com/tags/ansible/"/>
    
  </entry>
  
</feed>
