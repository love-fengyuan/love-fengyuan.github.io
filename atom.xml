<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>永远在路上 生命不息 学习不止</title>
  
  <subtitle>请道上大佬，多多指教</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.baidu.com/"/>
  <updated>2019-05-05T07:30:06.599Z</updated>
  <id>http://www.baidu.com/</id>
  
  <author>
    <name>YuanFeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LVS</title>
    <link href="http://www.baidu.com/2019/04/18/LVS/"/>
    <id>http://www.baidu.com/2019/04/18/LVS/</id>
    <published>2019-04-18T15:22:43.000Z</published>
    <updated>2019-05-05T07:30:06.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h1><p>LVS(linux virtual server)即linux虚拟服务器，是一个虚拟的服务器集群系统。</p><p>使用集群技术和Linux操作系统实现一个高性能,高可用的服务器,很好的可伸缩性(scalability),很好的可靠性(reliability),很好的可管理性(manageability).</p><p>contos7:</p><p>grep -i ipvs /boot/config-3.10.0-693.e17.x86_64</p><p>grep -i ipvs -C 10 /boot/config-3.10.0-693.e17.x86_64</p><p>yum install ipvsadm</p><p>rpm -ql ipvsadm</p><p>curl命令</p><p>lvs服务器:<br>需要两块网卡</p><p>启用Ipforward：</p><pre><code>echo net.ipv4.ip_forward=1 &gt;&gt; /etc/sysctl.conf</code></pre><p>sysctl -p</p><p>sysctl -a | grep ip_forward</p><p>iptables -vnl</p><p>client：<br>需要桥接</p><p>RS1：<br>设置网关</p><pre><code>yum install httpdecho RS1 &gt; /var/www/html/index.html</code></pre><p>RS2；<br>设置网关</p><pre><code>yum install httpdecho RS2 &gt; /var/www/html/index.html</code></pre><p>LVS：</p><p>定义ipvs规则:NAt模式</p><pre><code>yum install ipvsadmipvsadm -A -t 172.20.0.200:80 -s rripvsadm -Lnipvsadm -a -t 172.20.0.200:80  -r 192.168.80.17 -mipvsadm -a -t 172.20.0.200:80  -r 192.168.80.27 -mipvsadm -Ln</code></pre><p>并发4百万 apache 1万</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="Cluster概念"><a href="#Cluster概念" class="headerlink" title="Cluster概念"></a>Cluster概念</h3><ul><li><p>系统扩展方式：</p><pre><code>scale up: 向上扩展，增强scale out: 向外扩展，增加设备，调度分配问题， cluster</code></pre></li><li><p>Cluster: 集群，未解决某个特定问题将多台计算机组合起来形成的单个系统</p></li><li><p>Linux Cluster类型：<br>  LB：load blancing, 负载均衡<br>  HA：high availiablity, 高可用， spof(single point of failure)</p><pre><code>MTBF: Mean Time Between Failure 平均无故障时间MTTR: Mean Time To REStoration (repair) 平均恢复前时间（故障时间）A=MTBF/(MTBF+MTTR) (0,1): 99%,99.5%, 99.9%, 99.99%, 99.999%</code></pre><p>  HPC: high-performance computing . 高性能 <a href="http://www.top500.org" target="_blank" rel="noopener">www.top500.org</a></p></li><li>分布式系统：<pre><code>分布式存储： 云盘分布式计算： hadoop, spark</code></pre></li></ul><h3 id="Cluster分类"><a href="#Cluster分类" class="headerlink" title="Cluster分类"></a>Cluster分类</h3><ul><li>LB Cluster的实现</li><li>硬件：<pre><code>F5 big-ipcitrix netscalerA10 A10</code></pre></li><li>软件:<pre><code>lvs: linux virtual servernginx: 支持七层调度haproxy: 支持七层调度ats: apache trafficserverperlbal: perl编写pound</code></pre></li><li>基于工作的协议层划分：</li><li>传输层（通用）：DPORT<br>  LVS：<br>  nginx：stream<br>  haproxy: mode tcp</li><li><p>应用层（专用）：针对特定协议，自定义的请求模型分类<br>  proxy server：</p><pre><code>http:nginx, httpdm haproxy(mode http),...fastcgi: nginx, httpd, ...mysql: mysql-proxy,...</code></pre></li><li><p>会话保持：负载均衡</p><pre><code>（1）session sticky: 同一用户调度固定服务器    source ip: lvs sh算法（对某一特定服务而言）    cookie（2）session replication: 每台服务器拥有全部session        session multicast cluster（3）session server: 专门的session服务器            memcached， redis</code></pre></li><li>HA集群实现方案<br>  keepalived: vrrp协议<br>  ais：应用接口规范<pre><code>heartbeatcman + rgmanager(RHCS)coresync_pacemaker</code></pre></li></ul><h2 id="LVS介绍"><a href="#LVS介绍" class="headerlink" title="LVS介绍"></a>LVS介绍</h2><h3 id="LVS介绍-1"><a href="#LVS介绍-1" class="headerlink" title="LVS介绍"></a>LVS介绍</h3><ul><li>LVS: linux virtual server, 负载调度器，集成内核<br>  官网：<a href="http://www.linuxvirtualserver.org/" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/</a><br>  VS：virtual server，负责调度<br>  RS：real server,负责真正提供服务<br>  L4：四层路由器或交换机</li><li>工作原理：vs根据请求报文的目标ip和目标协议及端口将其调度转发至某RS，根据调度算法来挑选RS</li><li>iptables/netfilter:<br>  iptables:用户空间的管理工具<br>  netfilter:内核空间上的框架<br>  流入：PREROUTING–&gt;INPUT<br>  流出：OUTPUT–&gt; POSTROUTING<br>  转发：PREROUTING–&gt;FORWARD–&gt;POSTROUTING<br>  DNAT：目标地址转换；PREROUTING</li></ul><h3 id="LVS概念"><a href="#LVS概念" class="headerlink" title="LVS概念"></a>LVS概念</h3><ul><li><p>lvs集群类型中的术语：<br>  VS：virtual server, director server(DS)</p><pre><code>dispatcher(调度器)，load balancer</code></pre><p>  RS:real server(lvs), upstream server(nginx)</p><pre><code>backend server(haproxy)</code></pre><p>  CIP:client ip<br>  VIP:virtual serve ip  VS外网的ip<br>  DIP:director ip  VS内网Ip<br>  RIP:real server ip</p><p>  访问流程：CIP<-->VIP==DIP<-->RIP</--></--></p></li></ul><h3 id="LVS集群的类型"><a href="#LVS集群的类型" class="headerlink" title="LVS集群的类型"></a>LVS集群的类型</h3><ul><li><p>lvs: ipvsadm/ipvs<br>  ipvsadm: 用户空间的命令行工具，规则管理器<br>  ipvs: 工作于内核空间netfilter的INPUT钩子上的框架</p></li><li><p>lvs集群的类型：<br>  lvs-nat: 修改请求报文的目标IP，多目标IP的DNAT<br>  lvs-dr: 操纵封装新的MAC地址<br>  lvs-tun: 在原请求IP报文之外新加一个IP首部<br>  lvs-fullnat: 修改请求报文的源和目标IP</p></li></ul><h3 id="lvs-nat模式"><a href="#lvs-nat模式" class="headerlink" title="lvs-nat模式"></a>lvs-nat模式</h3><ul><li>lvs-nat:<br>  本质是多目标IP的DNAT，通过将请求报文中的目标地址和目标端口修改为某挑出的RS的RIP和PORT实现转发<br>  (1)RIP和DIP应在同一个IP网络，且应使用私网地址，RS的网关要指向DIP<br>  (2)请求报文和响应报文都必须经由Director转发，Director易于成为系统瓶颈<br>  (3)支持端口映射，可修改请求报文的目标PORT<br>  (4)VS必须是linux系统，RS可以是任意OS系统</li></ul><h3 id="lvs-fullnat模式"><a href="#lvs-fullnat模式" class="headerlink" title="lvs-fullnat模式"></a>lvs-fullnat模式</h3><ul><li>lvs-fullnat:<br>  通过同时修改请求报文的源IP地址和目标IP地址进行转发<pre><code>CIP--&gt;DIPVIP--&gt;RIP</code></pre>  (1)VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此。RIP的网关一般不会指向DIP<br>  (2)RS收到的请求报文源地址是DIP，因此，只需响应给DIP；但Director还要将其发往Client<br>  (3)请求和响应报文都经由Director<br>  (4)支持端口映射<br>  注意：此类型kernel默认不支持</li></ul><h3 id="LVS工作模式总结"><a href="#LVS工作模式总结" class="headerlink" title="LVS工作模式总结"></a>LVS工作模式总结</h3><table><thead><tr><th></th><th>VS/NAT</th><th>VS/TUN</th><th>VS/DR</th></tr></thead><tbody><tr><td>server</td><td>any</td><td>tunneling</td><td>non-arp device</td></tr><tr><td>server network</td><td>private</td><td>LAN/WAN</td><td>LAN</td></tr><tr><td>server number</td><td>low(10~20)</td><td>high(100)</td><td>high(100)</td></tr><tr><td>server gateway</td><td>load balancer</td><td>own router</td><td>own router</td></tr></tbody></table><ul><li><p>lvs-nat与lvs-fullnat:请求和响应报文都经由director<br>  lvs-nat:RIP的网关要指向DIP<br>  lvs-fullnat：RIP和DIP未必在同一IP网络，但要能通信</p></li><li><p>lvs-dr与lvs-tun:请求报文要经由director，但相应报文有RS直接发往client<br>  lvs-dr：通过封装新的MAC首部实现，通过MAC网络转发<br>  lvs-tun: 通过在院IP报文外封装新IP头实现转发，支持远距离通信</p></li></ul><h3 id="ipvs-scheduler"><a href="#ipvs-scheduler" class="headerlink" title="ipvs scheduler"></a>ipvs scheduler</h3><ul><li>ipvs scheduler:<br>  根据其调度时是否考虑各RS当前的负载状态<br>  两种：静态方法和动态方法</li><li><p>静态方法：仅根据算法本身进行调度</p><pre><code>1. RR: roundrobin,轮询2. WRR: weighted RR,加权轮询3. SH: source hashing,实现session sticky，源IP地址hash；将来自同一个IP地址的请求，始终发往第一次挑中的RS，从而实现会话绑定4. DH: destination hashing, 目标地址哈希，将发往同一个目标地址的骑牛始终发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡；如：宽带运行商</code></pre></li><li><p>动态方法：<br>  主要根据每个RS当前的负载状态及调度算法进行调度overhead=value较小的RS将被调度</p><ol><li>LC: least connections 适用于长连接应用<br> overhead=activeconns*256+inactiveconns</li><li>WLC: weighted LC,默认调度方法<br> overhead=(acticeconns*256+inactiveconns)/weight</li><li>SED: shortest expection delay,初始连接高权重优先<br> overhead=(activeconns+1)*256/weight</li><li>NQ: never queue, 第一轮均匀分配，后续sed</li><li>LBLC: locality-based LC，动态的DH算法，使用场景：根据负载状态实现正向代理</li><li>LBLCR: LBLC with replication, 带复制功能的LBLC，解决LBLC负载不均衡问题，从负载重的复制到负载轻的RS</li></ol></li></ul><h3 id="ipvsadm命令"><a href="#ipvsadm命令" class="headerlink" title="ipvsadm命令"></a>ipvsadm命令</h3><ul><li>ipvsadm 命令：</li><li><p>核心功能：</p><pre><code>集群服务管理：增，删，改集群服务的RS管理：增，删，改查看</code></pre><p>  ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] [-M netmask] [–pe persistence_engine] [-b sched-flags]<br>  ipvsadm -D -t|u|f service-address 删除<br>  ipvsadm -C 清空<br>  ipvsadm -R 重载<br>  ipvsadm -S [-n] 保存<br>  ipvsadm -a|e -t|u|f service-address -r server-address [options]<br>  ipvsadm -d -t|u|f service-address -r server-address<br>  ipvsadm -L|l [options]<br>  ipvsadm -Z [-t|U|f service-address]</p></li><li><p>管理集群上的RS：增，删，改</p></li><li>增、改：ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m]  [-w weight]</li><li>删：ipvsadm -d -t|u|f service-address -r server-address</li><li>server-addres:<br>  rip[:port] 如省略port，不作端口映射</li><li>选项：<br>  lvs类型:<pre><code>-g: gateway, dr类型，默认-i: ipip，tun类型-m: masquerade, nat类型</code></pre>  -w weight: 权重</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sina.com.cn/s/blog_6786545e0102vjvq.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6786545e0102vjvq.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LVS&quot;&gt;&lt;a href=&quot;#LVS&quot; class=&quot;headerlink&quot; title=&quot;LVS&quot;&gt;&lt;/a&gt;LVS&lt;/h1&gt;&lt;p&gt;LVS(linux virtual server)即linux虚拟服务器，是一个虚拟的服务器集群系统。&lt;/p&gt;
&lt;p&gt;使用集群技术和
      
    
    </summary>
    
      <category term="lvs" scheme="http://www.baidu.com/categories/lvs/"/>
    
    
      <category term="lvs" scheme="http://www.baidu.com/tags/lvs/"/>
    
  </entry>
  
  <entry>
    <title>plan</title>
    <link href="http://www.baidu.com/2019/04/05/plan/"/>
    <id>http://www.baidu.com/2019/04/05/plan/</id>
    <published>2019-04-05T09:36:34.000Z</published>
    <updated>2019-05-03T17:52:52.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="plan"><a href="#plan" class="headerlink" title="plan"></a>plan</h1><p>Q:web压力测试工具</p><p>A:Apache JMeter // Web Application Stress Tool // gatling // locust</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>Mysql / Mongodb / Redis<br>Tomact  Nginx<br>Kubernetes / Docker<br>python shell<br>Ansible/ Puppet / SaltStack / Fabric<br>Zabbix/ Nagios / Cacti / Grafana / Prometheus / ELK /<br>Kafka</p><p>jenkins / gitlab /</p><p>Lvs / Haproxy<br>LAMP / LNMP/</p><p>DAS/SNA/NAS/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;plan&quot;&gt;&lt;a href=&quot;#plan&quot; class=&quot;headerlink&quot; title=&quot;plan&quot;&gt;&lt;/a&gt;plan&lt;/h1&gt;&lt;p&gt;Q:web压力测试工具&lt;/p&gt;
&lt;p&gt;A:Apache JMeter // Web Application Stress T
      
    
    </summary>
    
      <category term="plan other" scheme="http://www.baidu.com/categories/plan-other/"/>
    
    
      <category term="plan" scheme="http://www.baidu.com/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>ansible</title>
    <link href="http://www.baidu.com/2019/03/10/ansible/"/>
    <id>http://www.baidu.com/2019/03/10/ansible/</id>
    <published>2019-03-10T15:06:52.000Z</published>
    <updated>2019-05-05T07:25:07.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h1><h2 id="Ansible-基础"><a href="#Ansible-基础" class="headerlink" title="Ansible 基础"></a>Ansible 基础</h2><ol><li>ANSIBLE_CONFIG  环境变量，可以定义配置文件的位置</li><li>./ansible.cfg    存在于当前工作目录</li><li>~/.ansible.cfg   存在于当前用户家目录</li><li>/etc/ansible/ansible.cfg 默认目录</li></ol><h2 id="Ansible命令"><a href="#Ansible命令" class="headerlink" title="Ansible命令"></a>Ansible命令</h2><p>主机要求：<br>windows除外</p><p>配置语言：<br>    yaml，json<br>只有server</p><p>role:<br>ansible 可以重复使用的</p><p>Ansible:</p><p><a href="https://github.com/ansible/ansible" target="_blank" rel="noopener">https://github.com/ansible/ansible</a></p><p>从release下载安装包</p><p>需要pip安装包的依赖</p><p>log：</p><p><a href="https://www.cnblogs.com/xielisen/p/6817807.html" target="_blank" rel="noopener">https://www.cnblogs.com/xielisen/p/6817807.html</a></p><p>查看文件个数：<br>ls -l | grep ‘^-‘ | wc -l </p><p>##################################马哥 Ansible</p><p>文件传输<br>命令执行：应用部署，配置管理，任务流编排</p><p>企业应用场景：<br>开发，测试，发布，生产，灰度环境（基于主机，用户，地区）</p><p>vie0 修改主机ip</p><p>ansible -m ping<br>m:模块<br>ansible 127.0.0.1 -m ping</p><p>在 /etc/ansible/hosts中配置主机清单</p><p>测试网络通讯;</p><pre><code>ansible 192.168.1.101 -m ping -k </code></pre><p>输入口令（密码）<br>k: 密码认证<br>建议基于key验证</p><pre><code>etc/ssh/sshd_config  ansible all -m ping  </code></pre><p>all: 代表主机清单的所有主机</p><h2 id="ansible-cfg"><a href="#ansible-cfg" class="headerlink" title="ansible.cfg"></a>ansible.cfg</h2><p>ansible.cfg</p><pre><code>forks=5     并发执行5</code></pre><p>ansible-doc:显示模块命令</p><p>ansible websevers –list-hosts</p><p>ansible all –list-host</p><p>ansible debserver -m ping -u wang -k    以wang的身份去连接</p><p>ansible debserver -m command -a ‘ls /root’ -u wang -k -b -K<br>以wang身份连接，切换到root用户权限，默认为root -K root口令</p><p>usermod -a -G wheel wang 将wang加入到组</p><p>K的口令;<br>sudo中：取消下面一行的注释：<br>%wheel ALL=(ALL)    NOPASSWD:ALL</p><p>基于key验证</p><pre><code>ssh-keygenssh-copy-id 192.168.80.101ssh-copy-id 192.168.80.102.......</code></pre><p>&amp; linux中表示后台执行</p><p>ansible all -m command -a “sleep 10”<br>休眠10s</p><p>command:</p><p>ansible all -a ‘ls /data’</p><p>ansible all -a ‘df -h’</p><p>ansible-doc command</p><p>creates 存在不执行</p><p>ansible all -a ‘removes=/etc/fs cat /etc/fstab’</p><p>removes 不存在不执行</p><p>ansible all -a ‘creates=/etc/fs cat /etc/fstab’</p><p>chdir  切换文件夹</p><p>ansible all -a ‘chdir=/root ls’</p><p>ansible 192.168.80.101 -a ‘/data/test.sh’</p><p>执行该主机上/data/test.sh</p><p>注： 注意规范 #！/bin/bash</p><p>创建账号：</p><pre><code>ansible all -a &apos;useradd test1&apos;</code></pre><p>查询：</p><pre><code>ansible all -a &apos;getent passwd test1&apos;</code></pre><p>command 命令对管道，重定向,变量 特殊符号支持有问题，建议shell</p><p>shell：</p><pre><code>ansible all -m shell -a &apos;echo $HOSTNAME&apos;</code></pre><p>更改口令:</p><pre><code>ansible all -m shell -a &apos;echo magedu|passwd --stdin test1&apos;</code></pre><p>script：</p><p>chmod +x test.sh</p><p>ansible all -m script -a ‘/root/ansible/test.sh’<br>在所有主机上执行test.sh</p><p>ansible all -a ‘getenforce’</p><p>cp /etc/sysconfig/selinux &gt;<br>vim selinux </p><p>copy:<br>ansible-doc -s copy</p><p>ansible all -m copy -a ‘src=/root/ansible/selinux dest=/etc/selinux/config backup=yes’<br>文件复制</p><p>ansible all -m shell -a ‘getenforce’</p><p>ansible all -m copy -a ‘src=/etc/shadow dest=/data mode=000 owner=root’</p><p>ansible all -m copy -a ‘content=”hello\n thanks \n “ dest=/data/f2’<br>直接写内容生成文件</p><p>fetch：<br>从客户端去文件到服务器端，与copy相反</p><p>ansible all -m fetch -a ‘src=/var/log/messages dest=/data’<br>从远程主机抓取log/message,到服务器，仅限单个文件</p><p>ansible all -m shell -a ‘tar jcf log.tar.xz /var/log/*.log’</p><p>包的加压与解压<br>archive<br>unarchive</p><p>file：</p><p>ansible all -m file -a ‘name=/data/f3 state=touch’  创建文件</p><p>ansible all -m file -a ‘name=/data/f3 state=absent’ 删除文件</p><p>ansible all -a ‘ls -l /data’</p><p>ansible all -m file -a ‘name=/data/dir1 state=directory’    创建文件夹，’state=absent’ 删除</p><p>‘src=/etc/fstab dest=/data/fstab.link state=link’   创建软连接</p><p>‘dest=/data/fstab.link state=absent’    删除软连接</p><p>‘dest=/data/* state=absent’ 删除所有文件</p><p>‘dest=/data/ state=absent’  删除文件夹</p><p>不能删除挂载点上的</p><p>ansible 192.168.80.101 -m hostname -a ‘name=new_name’ 修改主机名</p><p>cron：</p><p>ansible all -m cron -a ‘minute=* weekday=1,3,5 job=”/usr/bin/wall FBI warning” name=warningcron’ 创建定时报警任务，写入crontab</p><p>ansible all -m cron -a ‘disabled=true job=”/usr/bin/wall FBI warning” name=warningcron’ 禁用此任务，必须加name</p><p>‘job=”/usr/bin/wall FBI warning” name=warningcron state=absent’ 删除</p><p>yum<br>/etc/yum.repos/base.repo yum仓库配置</p><p>ansible all -m yum -a ‘name=vsftpd’<br>安装<br>多个软件用’,’隔开</p><p>ansible all -m yun -a ‘list=instealled’ 安装过的列表</p><p>‘name=vsftpd state=removed’卸载</p><p>‘name=vsftpd state=absent’</p><p>‘rpm -q vsftpd’ 查找是否卸载</p><p>安装下载好的软件；<br>ansible all -m copy -a ‘src=/data/softname dest=/root/‘</p><p>ansible all -a ‘ls /root/‘</p><p>ansbile all -m yum -a ‘name=/root/softname’</p><p>disable_gpg_check=yes 忽略，禁用</p><p>‘name=dstat update_cache=yes’ 更新缓存</p><p>services:</p><p>ansible all -m services -a ‘name=vsftpd state=started enabled=yes’<br>启动服务，同时设为开机启动  </p><p>user:</p><p>ansible all -m user -a ‘name=nginx shell=/sbin/nologin system=yes home=/var/nginx groups=root,bin uid=80 comment=”nginx service”‘</p><p>创建账号</p><p>ansible all -m user -a ‘name=nginx state=absent remove=yes’ 删除账号，删除home目录</p><p>group:</p><p>ansible all -m group -a ‘name=nginx system=yes gid=80’</p><p>ansible all -a ‘getent group nginx’</p><p>ansible -m group -a ‘name=nginx state=absent’  删除</p><p>ansible-galaxy:</p><p>ansible-galaxy install geerlingguy.nginx</p><p>yml/yaml:</p><p>注意缩进，格式</p><pre><code>----hosts:webserverremote_user:roottasks:    -name:hello    command：hostname</code></pre><p>ansible-playbook test.yaml</p><p>ansible-vault:<br>ansible-vault encrypt test.yaml     对文件进行加密，避免敏感信息泄露</p><p>需要设置加密口令,再次执行yaml时会报错，</p><p>ansible-vault decrypt test.yaml     解密</p><p>ansible-vault view test.yaml   查看yaml需要输入口令</p><p>ansible-vault rekey test.yaml  修改密码</p><p>ansible-vault create test2.yaml     创建新的playbook文件</p><p>ansible-console:</p><p>交互式：<br>ansible-console</p><p>“root@all (3)[f:5]$ “ 并发数量为5也可以修改forks 10</p><p>cd 192.168.80.135  切换到135主机</p><p>hostname name=node2.magedu.com 修改主机名</p><h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>playbook采用YAMl语言编写</p><p>1.# test yaml 注释<br>2.缩进必须统一</p><pre><code>---- hosts:webserverremote_user:roottasks:    - name:create new file  #描述    file:name=/data/newfile state=touch   模块/命令    - name:create new user    user: name=test2     - name: install httpd    yum:name=httpd    - name:copy conf    copy:src=/etc/conf dest=/etc/conf    - name:start service    service:name=httpd state=started enables=yes</code></pre><p>ansible-playbook -C file.yml    # -C 检查</p><p>ansible all -a ‘getent passwd test2’    #查看test2用户</p><p>ansible all -m shell -a ‘ss -tln | grep :80’    #查看80端口</p><p>ansible all -a ‘getent passwd test2’ –limit 192.168.80.134</p><p>ansibel-playbook file.yml –list</p><p>ansibel-playbook file.yml –list-tasks</p><pre><code>- name:copy a filecopy:src=files/test.py dest=/etc/test.py  #files相对路径，相对于当前目录</code></pre><p>注：文件修改后再次执行copy，不会生效</p><p> 更新配置文件，执行playbook后，并不会生效</p><pre><code>http.yml---- hosts: webserverremote_user:roottasks:    - name:install https package    yum:name-httpd    - name: copy conf file    copy: src=files/httpd.conf dest=/etc/httpd/conf baskup=yes    - name: start service    service: name=httpd state=started enabled=yes</code></pre><p>执行http.yml，修改配置文件后，执行不会重启</p><pre><code>http.yml---- hosts: webserver  remote_user:root  tasks:    - name:install https package    yum:name-httpd    tag:inshttpd    - name: copy conf file    copy: src=files/httpd.conf dest=/etc/httpd/conf baskup=yes    notify:restart service    - name: start service    service: name=httpd state=started enabled=yes    tag:rshttpd  handlers:    - name: restart service      service: name=http state=restarted</code></pre><p>也可以同时触发两个任务</p><p>tags：</p><p>添加标签，可以单独执行标签</p><p>多个动作共用一个标签</p><p>ansible-playbook -t rshttpd httpd.yml</p><p>ansible-playbook -t inshttpd,rshttpd httpd.yml</p><p>setup:</p><p>ansible all -m setup -a ‘filter=ansible_hostname’</p><p>ansible all -m setup -a ‘filter=<em>address</em>‘\</p><p>ansible all -m setup -a ‘filter=ansible_all_ipv4_address’</p><pre><code>app.yml---- hosts: webserverremote_user: roottasks:    - name: install packing    yum: name={{ pkname }}    - name: start service    service: name={{ pkname }} state=started enabled=yes</code></pre><p>ansible-playbook -e ‘pkname=httpd’ app.yml</p><p>pkname 不会写死，灵活定义</p><p>也可以同时装多个包，用逗号隔开</p><p>eg：</p><pre><code>---- hosts:websever  remote_user: root  vars:    - pkname1: httpd    - pkname2: vsftpd  tasks:    - name:install pachage      yum: name={{ pkname1 }}    - name: install package      yum: name={{ pkname2 }}</code></pre><p>定义变量在playbook中，</p><pre><code>hostname.yml:---- hosts: webserver  rempte_user: root  tasks:    - name: set hostname      hostname: name= www{{http_port}}.magedu.com</code></pre><p>hosts：</p><pre><code>[webserver:vars]nodenamw=wwwdomainname=magedu.com</code></pre><p>此处的变量对webserver所有主机有效</p><pre><code>tasks:  - name: set hostname    hostname：name={{nodename}}{{http_port}}.{{domasinname}}</code></pre><p>命令行优先级高于配置文件</p><p>ansible all -m setup<br>ansible all -m setup -a ‘filter=”ansbile_fqdn”‘</p><pre><code>var.yml---- hosts:webserverrenote_use: roottasks:    - name: create a file    file: name=/data/{{ ansible_fqdn }}.log state=touch mode=600 owner=wang</code></pre><p>ansible-playbook -c var.yml</p><p>vars.yml</p><p>var1: httpd<br>var2: vsftpd</p><pre><code>testvars.yml---- hosts: webserver  remote_user: root  vars_file:    - vars.yml  tasks:    - name：install package      yum: name={{ var1 }}    - name: create file      file: name= /data/{{ var2 }}.log state=touch</code></pre><p>template.yml</p><pre><code>---- hosts: webserverremote_user: roottasks:     - name: install package    tum: name=nginx    - name: copy template    template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf    - name start service    service: name=nginx state=started enabled=yes</code></pre><p>ansible all -m shell -a ‘ss -ntpl’  #查看端口</p><p>nginx.conf中修改:</p><p>worker_processes NaN     #cpu个数的2次方</p><p>修改template.yml</p><pre><code>---- hosts: webserverremote_user: roottasks:     - name: install package    tum: name=nginx    - name: copy template    template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf    notify: start service    - name start service    service: name=nginx state=started enabled=yeshandlers:    - name: restart service      service: name=nginx state=restarted</code></pre><p>ansible all -m shell -a ‘ps aux | grep nginx’   #过滤nginx进程</p><p>hosts：也可以写成如下模式</p><p>[webserver]<br>192.168.80.134 http_port=81<br>192.168.80.135 http_port=82</p><p>ansible-playbook -e ‘http_port=99’ testtemp.yml  #修改端口</p><p>优先级：命令行&gt;playbook&gt;主机清单</p><p>ansibel all -m setup -a ‘filte=ansible_os_family’</p><p>‘filter=”<em>distribution</em>“‘</p><p>testitem.yml</p><pre><code>---- hosts: webserverremote_user: roottasks:    - name: create some files      file: name=/data/{{ item }} state=touch      when: ansible_distribution_major_version == &quot;7&quot;      with_items:        - file1        - file2        - file3    - name: install spme package      yum: name={{ item }}      with_items:        - htop        - sl        - hping3</code></pre><p>create_group.yml</p><pre><code>---- hosts: all  remote_user: root  tasks:    - name: create some groups      group: name={{ item }}      when: ansible_distribution_major_version == &quot;7&quot;      with_items:        - g1        - g2         - g3</code></pre><p>创建用户，并加入到组</p><pre><code>---- hosts: all  remote_user: root  tasks:    - name: create some groups      group: name={{ item }}      when: ansible_distribution_major_version == &quot;7&quot;      with_items:        - g1        - g2         - g3    - name:create some users      user: name={{item.name}} group={{item.group}}      with_items:        - { name: &apos;user1&apos;, group: &apos;g1&apos; }        - { name: &apos;user2&apos;, group: &apos;g2&apos; }        - { name: &apos;user3&apos;, group: &apos;g3&apos; }</code></pre><hr><p>for:</p><p>testfor.yml</p><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - 81      - 82      - 83  tasks:    - name: copy conf      template: src=for1.conf.j2 dest=/data/for1.conf</code></pre><p>创建文件：for1.conf.j2</p><pre><code>{% for port in ports %}    server{        listen {{ port }}    }    {% endfor %}</code></pre><hr><p>修改为字典模式：</p><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - listen_port:81      - listen_port:82      - listen_port:83  tasks:    - name: copy conf      template: src=for2.conf.j2 dest=/data/for1.conf   </code></pre><p>for2.conf.j2</p><pre><code>{% for port in ports %}    server{        listen {{ port.listen_port }}    }    {% endfor %}</code></pre><hr><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - web1:        port: 81        name: web1.magedu.com        rootdir: /data/website1      - web2:        port: 83        name: web2.magedu.com        rootdir: /data/website2      - web3:        port: 83        name: web3.magedu.com        rootdir: /data/website3  tasks:    - name: copy conf      template: src=for3.conf.j2 dest=/data/for1.conf </code></pre><p>for3.conf.j22</p><pre><code>{% for p in ports %}    server{        listen {{ p.port }}        servername {{ p.name }}        documentroot {{ p.rootdir }}    }    {% endfor %}</code></pre><hr><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - web1:        port: 81        #name: web1.magedu.com        rootdir: /data/website1      - web2:        port: 83        name: web2.magedu.com        rootdir: /data/website2      - web3:        port: 83        #name: web3.magedu.com        rootdir: /data/website3  tasks:    - name: copy conf      template: src=for4.conf.j2 dest=/data/for4.conf</code></pre><p>for4.conf.j22</p><pre><code>{% for p in ports %}    server{        listen {{ p.port }}    {% if p.name is defined %}        servername {{ p.name }}    {% endif %}        documentroot {{ p.rootdir }}    }    {% endfor %}</code></pre><h2 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h2><p>创建roles文件夹：</p><p>mkdir roles</p><p>mkdir roles/{httpd, mysql, memcache} -pv</p><p>mkdir roles/nginx</p><p>ansible all -m shell -a ‘rpm -q nginx’</p><p>‘getent group nginx’</p><p>‘userdel -f nginx’ 删除用户，组</p><p>cd nginx</p><p>mkdir tasks templates</p><p>cd tasks</p><p>vim group.yml</p><pre><code>- name:create group  group: name=nginx gid=80</code></pre><p>vim user.yml</p><pre><code>- name: create user  user: name=nginx group=nginx system=yes shell=/sbin/nologin uid=80</code></pre><p>vim yum.yml</p><pre><code>- name: install package  yum: name=nginx</code></pre><p>vim start.yml</p><pre><code>- name: start service  service: name=nginx state=started enabled=yes</code></pre><p>vim restart.yml</p><pre><code>- name: restart service  sservice: name=nginx  state=restarted</code></pre><p>templates:</p><p>nginx.conf.j2(nginx.conf重命名为此)</p><p>vim temp.yml</p><pre><code>- name: copy conf  template: src=nginx.conf.j2 dest=/etc/ngiunx/nginx.conf</code></pre><p>vim main.yml</p><pre><code>- include: group.yml- include: user.yml- include: yum.yml- include: temp.yml- include: start.yml</code></pre><p>调用的剧本与roles同级</p><p>vim nginx_role.yml</p><pre><code>- hosts: all  remote_usr: root  roles:    - role: nginx</code></pre><p>ansibel-playbook -c nginx_role.yml</p><hr><p>httpd_roles</p><p>mkdir tasks</p><p>vim user.yml</p><pre><code>- name: create user  user: name=apache system=yes shell=/sbin/nologin</code></pre><p>vim copyfile.yml</p><pre><code>- name: copy file  file: src= dest=</code></pre><hr><p>httpd：</p><p>tasks：</p><p>vim user.yml</p><pre><code>- name: create user  user: name=apache system=yes shell=/sbin/nologin</code></pre><p>vim copyfile.yml</p><pre><code>- name: copy file  copy: src=httpd.conf dest=/data/</code></pre><p>vim main.yml</p><pre><code>- include: user.yml- include: copyfile.yml</code></pre><p>vim httpd_role.yml</p><pre><code>- hosts: all  remote_user: root  roles:    - role: httpd</code></pre><p>在一个角色中，调用另一个角色</p><p>vim some_role.yml</p><pre><code>- hosts: all  remote_user：root  roles:    - role: http    - role: nginx</code></pre><p> 一个角色引用另一个角色中的任务<br>在main.yml中添加一行</p><pre><code>- include: roles/httpd/tasks/copyfileyml</code></pre><p>此处需要注意路径的选择</p><p>ansible.cfg</p><p>当playbook失败的情况下，一个重试文件将会创建，后缀为retry，默认开启此功能</p><p>添加标签：<br>some_role.yml</p><pre><code>---- hosts: all  remote_user: root  roles:    - { role: httpd, tags:[&apos;web&apos;, &apos;httpd&apos;] }    #即属于web，也属于httpd    - { role: nginx, tags:[&apos;web&apos;, &apos;nginx&apos;] }</code></pre><p>ansible-playbook -t web some_role.yml   #只执行标签web</p><p>some_role.yml</p><pre><code>---- hosts: all  remote_user: root  roles:    - { role: httpd, tags:[&apos;web&apos;, &apos;httpd&apos;] }    #即属于web，也属于httpd    - { role: nginx, tags:[&apos;web&apos;, &apos;nginx&apos;] , when: ansible_distribution_major_version == &apos;7&apos;}    # 当版本为7的时候执行</code></pre><hr><p>mkdir app<br>cd app<br>mkdir tasks templates vars handlers files</p><p>task:</p><p>vim group.yml</p><pre><code>- name: create group  group: name=app system=yes gid=123</code></pre><p>vim user.yml</p><pre><code>- name: create user  user: name=app group=app system=yes shell=/sbin/nologin uid=1223</code></pre><p>vim yum.yml</p><pre><code>- name: isntall package  yum: name=httpd</code></pre><p>vim templ.yml</p><pre><code>- name: copy conf  template: src=httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf  notify: restart service</code></pre><hr><p>vars:<br>main.yml    </p><pre><code>username:appgroupname: app</code></pre><hr><p>handlers:<br>vim main.yml</p><pre><code>- name: restart service  service: name=httpd state=restarted</code></pre><hr><p> tasks:<br> vim start.yml</p><pre><code>- name: start service  service: name=httpd state=started enabled=yes</code></pre><p>vim copyfile.yml</p><pre><code>- name: copy config  copy: src=vhosts.conf dest=/etc/httpd/conf.d/ owner=app</code></pre><p>vim main.yml</p><pre><code>- include: group.yml- include: user.yml- include: yum.yml- include: templ.yml- include: copyfile.yml- include: start.yml</code></pre><hr><p>files:<br>touch vhosts.conf</p><hr><p>app_role.yml</p><pre><code>- hosts: all  remote_user: root  roles:    - app</code></pre><p>memcached:</p><p>yum install memcached</p><p>cat /etc/sysconfig/memcached</p><p>cp /etc/sysconfig/memcached templates/memcached.j2<br>修改：<br>CACHESIZE=”NaN“</p><p>vim tasks/yum.yml</p><pre><code>- name: install package  yum: name=memcached</code></pre><p>vim taska/start.yml</p><pre><code>- name: start service  service: name=memcached state=started enabled=yes</code></pre><p>vim /tasks/templ.yml</p><pre><code>- name: copy conf  templates: src=memcached.j2 dest=/etc/sysconfig/memcached</code></pre><p>vim tasks/main.yml</p><pre><code>- include: yum.yml- include: templ.yml- include: start.yml</code></pre><p>vim memcached_role.yml</p><pre><code>- hosts: all  remote_user: root  roles:    - memcached</code></pre><p>ansible-playbook -C memecached_role.yml</p><p>ansible-playbook memcached_role.yml</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ansible&quot;&gt;&lt;a href=&quot;#Ansible&quot; class=&quot;headerlink&quot; title=&quot;Ansible&quot;&gt;&lt;/a&gt;Ansible&lt;/h1&gt;&lt;h2 id=&quot;Ansible-基础&quot;&gt;&lt;a href=&quot;#Ansible-基础&quot; class=&quot;head
      
    
    </summary>
    
      <category term="ansible" scheme="http://www.baidu.com/categories/ansible/"/>
    
    
      <category term="ansible" scheme="http://www.baidu.com/tags/ansible/"/>
    
  </entry>
  
</feed>
