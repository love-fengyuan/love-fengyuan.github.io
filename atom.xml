<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>永远在路上 生命不息 学习不止</title>
  
  <subtitle>请道上大佬，多多指教</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.baidu.com/"/>
  <updated>2019-05-05T12:38:32.852Z</updated>
  <id>http://www.baidu.com/</id>
  
  <author>
    <name>YuanFeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>django</title>
    <link href="http://www.baidu.com/2019/05/06/django/"/>
    <id>http://www.baidu.com/2019/05/06/django/</id>
    <published>2019-05-05T20:38:32.000Z</published>
    <updated>2019-05-05T12:38:32.852Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://www.baidu.com/2019/05/06/nginx/"/>
    <id>http://www.baidu.com/2019/05/06/nginx/</id>
    <published>2019-05-05T19:56:58.000Z</published>
    <updated>2019-05-05T12:18:50.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx服务"><a href="#Nginx服务" class="headerlink" title="Nginx服务"></a>Nginx服务</h2><h2 id="Nginx现状"><a href="#Nginx现状" class="headerlink" title="Nginx现状"></a>Nginx现状</h2><p>​nginx 是当前的使用最广泛的webserver ,支持http正向/反向代理，支持TCP/UDP层代理，nginx在全部网站中占比较高，而且一直在增加。当下最时尚的webserver非nginx莫属。</p><h2 id="Nginx特点"><a href="#Nginx特点" class="headerlink" title="Nginx特点"></a>Nginx特点</h2><ul><li>性能好<ul><li>非阻塞IO/高并发(asyncio/aiohttp),支持文件IO</li><li>多worker，thread pool（线程池- 线程队列）</li><li>基于rbtree的定时器</li><li>系统特性的持续支持</li></ul></li><li>功能强大<ul><li>webserver/cache/keepalive/pipeline等等</li><li>各种upstream的支持【fastcgi/http/…】</li><li>输出灵活【chunk/zip/…】</li><li>在不断的发展 http2,tcp,udp,proxy…</li></ul></li><li>运维的友好【这个对于开发和部署很重要】<ul><li>配置非常规范【个人认为：约定及规范是最好的实践】</li><li>热加载和热更新【后文会详细介绍，能在二进制的层面热更新】</li><li>日志强大【真的很强的，很多变量支撑】</li></ul></li><li>扩展强大</li></ul><p>​     下图是nginx、apache和lighttpd的一个对比。系统压力，内存占用，upstream支持等多个方面都非常不错<br>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://cuihuan.net/wp_content/new/nginx1/nginx_compare.png" alt="nginx对比图](nginx/nginx_compare.png)" title>                </div>                <div class="image-caption">nginx对比图](nginx/nginx_compare.png)</div>            </figure></p><p>HTTPS = HTTP + SSL</p><h2 id="Nginx工作原理"><a href="#Nginx工作原理" class="headerlink" title="Nginx工作原理"></a>Nginx工作原理</h2><p>​Nginx的运行方式：<code>master-worker多进程模式运行，单线程/非阻塞执行</code></p><p>​Nginx 启动后生成master，master会启动conf数量的<code>worker进程</code>，当用户的请求过来之后，由不同的worker调起<code>执行线程</code>，非阻塞的执行请求。这种运行方式相对于<code>apache的进程执行</code>相对轻量很多，支撑的并发性也会高很多。   </p><p>​Nginx 默认采用守护模式启动，守护模式让master进程启动后在后台运行。在Nginx运行期间主要由一个master主进程和多个worker进程（worker数目一般与cpu数目相同）</p><h3 id="1-master主进程"><a href="#1-master主进程" class="headerlink" title="(1)master主进程"></a>(1)master主进程</h3><ul><li>master主进程主要是管理worker进程，对网络事件进行收集和分发：</li></ul><ol><li>接收来自外界的信号</li><li>向各worker进程发送信号</li><li>监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程</li></ol><h3 id="2-worker-工作进程"><a href="#2-worker-工作进程" class="headerlink" title="(2)worker 工作进程"></a>(2)worker 工作进程</h3><p>​     nginx用一个独立的worker进程来处理一个请求，一个worker进程可以处理多个请求：</p><p>​     a.  当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接。</p><p>​     b.  一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。采用这种方式的好处：</p><ul><li><ul><li>节省锁带来的开销。对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查上时，也会方便很多</li><li>独立进程，减少风险。</li><li>采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快重新启动新的worker进程。</li><li>在一次请求里无需进程切换</li></ul></li></ul><h3 id="3-Nginx的IO处理过程"><a href="#3-Nginx的IO处理过程" class="headerlink" title="(3) Nginx的IO处理过程"></a>(3) Nginx的IO处理过程</h3><p>​一般的Tcp Socket处理过程：</p><p>​服务端：fd = socket.socket   —&gt; fd.bind()   —&gt; fd.listen()   —&gt; accept()  等待客户端连接  —&gt;  send / recv  —&gt; close()</p><p>客户端：fd = socket.socket  —&gt; fd.connect()  与服务端建立连接  —&gt; recv / send   —&gt; close()</p><p>​Nginx的网络IO处理通常使用epoll，epoll函数使用了I/O复用模型。与I/O阻塞模型比较，I/O复用模型的优势在于可以同时等待多个（而不只是一个）套接字描述符就绪。Nginx的epoll工作流程如下：</p><ul><li><ul><li>master进程先建好需要listen的socket后，然后再fork出多个woker进程，这样每个work进程都可以去accept这个socket</li><li>当一个client连接到来时，所有accept的work进程都会受到通知，但只有一个进程可以accept成功，其它的则会accept失败，Nginx提供了一把共享锁accept_mutex来保证同一时刻只有一个work进程在accept连接，从而解决惊群问题。</li><li>当一个worker进程accept这个连接后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完成的请求就结束了.</li></ul></li></ul><h2 id="Nginx-安装与配置"><a href="#Nginx-安装与配置" class="headerlink" title="Nginx 安装与配置"></a>Nginx 安装与配置</h2><p>​Nginx服务学习我们借助于一个第三方库Openresty，它本身就是把nginx核心代码做了一层封装，你完全可以把它当成Nginx使用。</p><p>​OpenResty 是一个基于 <a href="https://openresty.org/cn/nginx.html" target="_blank" rel="noopener">Nginx</a> 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p><p>​OpenResty 的目标是让你的Web服务直接跑在 <a href="https://openresty.org/cn/nginx.html" target="_blank" rel="noopener">Nginx</a> 服务内部，充分利用 <a href="https://openresty.org/cn/nginx.html" target="_blank" rel="noopener">Nginx</a> 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。</p><p>Openresty下载页：</p><p><a href="https://openresty.org/cn/download.html" target="_blank" rel="noopener">https://openresty.org/cn/download.html</a></p><p>下载版本：wget  <a href="https://openresty.org/download/openresty-1.11.2.5.tar.gz" target="_blank" rel="noopener">https://openresty.org/download/openresty-1.11.2.5.tar.gz</a>  (Ubuntu 16.x)</p><p>最新版本： wget  <a href="https://openresty.org/download/openresty-1.13.6.2.tar.gz" target="_blank" rel="noopener">https://openresty.org/download/openresty-1.13.6.2.tar.gz</a> (Ubuntu 17.10)</p><p>性能测试工具 Apache AB test</p><p>安装过程：</p><p>（1）安装依赖库：</p><pre><code>sudo apt install libpcre3  libpcre3-devsudo apt install openssl libssl-dev</code></pre><p>（2）安装openresty </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#将openresty安装到/opt/openresty目录下</span><br><span class="line">sudo mkdir /opt/openresty   </span><br><span class="line">#修改组和用户权限 apple用户名 : apple组</span><br><span class="line">sudo chown -Rf apple:apple /opt/openresty/</span><br><span class="line">tar -xzvf openresty-1.11.2.5.tar.gz</span><br><span class="line">cd openresty-1.11.2.5 </span><br><span class="line">./configure  --prefix=/opt/openresty    (注:./configure --help 查看更多的配置选项)</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>至此，安装完成，安装openresty就在/opt/openresty目录下。</p><p>（3）目录介绍</p><pre><code>bin                          openresty 的启动文件COPYRIGHT             版权文件luajit                        lua虚拟环境luajitlualib                       lua实现的第三方库，包括redis， mysql， upload， upstream，websocket等等。nginx                      nginx核心功能块pod     resty.index    site</code></pre><p>​openresty不只是提供了nginx功能，而且提供了丰富的工具集，我们可以做除了负载均衡和反向代理之外的很多事情，快速搭建出高性能web服务。</p><p>查看进程和端口：</p><p>ps -ef | grep 80</p><p>netstat -tunpl | grep 80  # </p><p>修改  vim  /opt/openresty/nginx/conf/nginx.conf 中，将listen 80改成 8080</p><p>启动nginx服务：</p><p>$ /opt/openresty/nginx/sbin/nginx</p><p>打开页面：<a href="http://172.16.245.180:8080/" target="_blank" rel="noopener">http://172.16.245.180:8080/</a> </p><p>​          <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p>可以看到 Welcome   to  OpenResty ！ 的页面，表示已经安装成功！</p><p>如果之前已安装了nginx 删除或停止它的服务：</p><p>​sudo apt remove nginx 或</p><p>​sudo servie nginx stop </p><h2 id="5-OpenResty-使用"><a href="#5-OpenResty-使用" class="headerlink" title="5 OpenResty 使用"></a>5 OpenResty 使用</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Openresty 框架的配置和nginx配置方法一样，配置文件: /opt/openresty/nginx/conf/nginx.conf</p><p>​Nginx主要通过nginx.conf文件进行配置使用。在nginx.conf文件中主要分为：</p><ul><li><ul><li>全局块：一些全局的属性，在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等</li><li>event块：参考事件模型，单个进程最大连接数等</li><li>http块：设定http服务器</li><li>server块：配置虚拟主机</li><li>location块：配置请求路由及页面的处理情况等</li></ul></li></ul><p>关键参数说明：</p><p>nginx进程数，建议设置为等于CPU总核心数。</p><p>worker_processes 8;</p><p>全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</p><p>error_log /usr/local/nginx/logs/error.log info;</p><p>进程pid文件</p><p>pid /opt/openresty/nginx/logs/nginx.pid;</p><p>指定进程可以打开的最大描述符：数目</p><p>工作模式与连接数上限</p><p>这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</p><p>worker_rlimit_nofile 65535;</p><p>虚拟主机的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    #监听端口</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    #域名可以有多个，用空格隔开, cat /etc/hosts</span><br><span class="line">    server_name www.jd.com jd.com; </span><br><span class="line">    index index.html index.htm index.php;</span><br><span class="line">    root /data/www/jd;</span><br><span class="line">    </span><br><span class="line">    #url 请求路由</span><br><span class="line">    location  /hello &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        content_by_lua &apos;</span><br><span class="line">            ngx.say(&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;)</span><br><span class="line">        &apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#负载均衡配置</span><br><span class="line">upstream piao.jd.com &#123;</span><br><span class="line">    #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weight参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">    server 192.168.80.121:80 weight=3;</span><br><span class="line">    server 192.168.80.122:80 weight=2;</span><br><span class="line">    server 192.168.80.123:80 weight=3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><p>拷贝我们的工程文件 artproject.zip，解压到某一个目录 eg:  /home/apple根目录下</p><p>配置nginx配置文件nginx.conf，添加如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /hello</span><br><span class="line">&#123;</span><br><span class="line">   default_type   text/html;</span><br><span class="line">   content_by_lua  &apos;</span><br><span class="line">       ngx.say(&quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;)&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 静态文件，nginx自己处理</span><br><span class="line">location  ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">   root   /home/apple/artproject/art;</span><br><span class="line">   # 过期1天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。</span><br><span class="line">   expires  1d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$ /opt/openresty/nginx/sbin/nginx -s stop, quit, reopen, reload</p><p>$ /opt/openresty/nginx/sbin/nginx -t  测试</p><p>nginx: the configuration file /opt/openresty/nginx/conf/nginx.conf syntax is ok</p><p>nginx: configuration file /opt/openresty/nginx/conf/nginx.conf test is successful</p><p>查看页面效果</p><p><a href="http://172.16.245.180:8080/hello" target="_blank" rel="noopener">http://172.16.245.180:8080/hello</a></p><p><a href="http://172.16.245.180:8080/static/admin/pages/index.html" target="_blank" rel="noopener">http://172.16.245.180:8080/static/admin/pages/index.html</a></p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>​负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><p>​Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略</p><h4 id="RR-（轮询策略）"><a href="#RR-（轮询策略）" class="headerlink" title="RR （轮询策略）"></a>RR （轮询策略）</h4><p>​按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。虽然这种方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。</p><h4 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h4><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;</span><br><span class="line">    server localhost:8080 weight=9;</span><br><span class="line">    server localhost:8081 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时8080和8081分别占90%和10%。</p><h4 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h4><p>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>fair(第三方) </li></ol><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    fair; </span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>url_hash(第三方) </li></ol><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123; </span><br><span class="line">    hash $request_uri; </span><br><span class="line">    hash_method crc32; </span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理动态请求转发到某一个服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">​         location = / &#123;  </span><br><span class="line"></span><br><span class="line">​                  proxy_pass   http://localhost:8080  </span><br><span class="line"></span><br><span class="line">​       &#125;</span><br></pre></td></tr></table></figure></p><p>​此处的proxy_pass 对应的服务，会导到上述upstream入口</p><h3 id="作为静态资源服务器"><a href="#作为静态资源服务器" class="headerlink" title="作为静态资源服务器"></a>作为静态资源服务器</h3><p>​Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作（CDN），这就是网站静态化处理的核心思路。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 静态文件，nginx自己处理</span><br><span class="line">location  ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">   root   /home/apple/artproject/art;</span><br><span class="line">   # 过期1天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。</span><br><span class="line">   expires  1d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于URL路由规则"><a href="#关于URL路由规则" class="headerlink" title="关于URL路由规则"></a>关于URL路由规则</h3><p>语法规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location [=|~|~*|^~] /uri/ </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">​     … </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>= 开头表示精确匹配</p><p>^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。</p><p>~ 开头表示区分大小写的正则匹配</p><p>~*  开头表示不区分大小写的正则匹配</p><p>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配 的正则</p><p>/ 通用匹配，任何请求都会匹配到。</p><p>多个location配置的情况下匹配顺序为：</p><p>首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</p><p>例子，有如下匹配规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">   #规则A</span><br><span class="line">&#125;</span><br><span class="line">location = /login &#123;</span><br><span class="line">   #规则B</span><br><span class="line">&#125;</span><br><span class="line">location ^~ /static/ &#123;</span><br><span class="line">   #规则C</span><br><span class="line">&#125;</span><br><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;</span><br><span class="line">   #规则D</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.png$ &#123;</span><br><span class="line">   #规则E</span><br><span class="line">&#125;</span><br><span class="line">location !~ \.xhtml$ &#123;</span><br><span class="line">   #规则F</span><br><span class="line">&#125;</span><br><span class="line">location !~* \.xhtml$ &#123;</span><br><span class="line">   #规则G</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">   #规则H</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么产生的效果如下:</p><p>访问根目录/， 比如<a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> 将匹配规则A<br>访问 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a> 将匹配规则B，<a href="http://localhost/register" target="_blank" rel="noopener">http://localhost/register</a> 则匹配规则H<br>访问 <a href="http://localhost/static/a.html" target="_blank" rel="noopener">http://localhost/static/a.html</a> 将匹配规则C<br>访问 <a href="http://localhost/a.gif" target="_blank" rel="noopener">http://localhost/a.gif</a>, <a href="http://localhost/b.jpg" target="_blank" rel="noopener">http://localhost/b.jpg</a> 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 <a href="http://localhost/static/c.png" target="_blank" rel="noopener">http://localhost/static/c.png</a> 则优先匹配到规则C<br>访问 <a href="http://localhost/a.PNG" target="_blank" rel="noopener">http://localhost/a.PNG</a> 则匹配规则E，而不会匹配规则D，因为规则E不区分大小写。</p><p>访问 <a href="http://localhost/a.xhtml" target="_blank" rel="noopener">http://localhost/a.xhtml</a> 不会匹配规则F和规则G，<a href="http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。" target="_blank" rel="noopener">http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。</a></p><p>访问 <a href="http://localhost/category/id/1111" target="_blank" rel="noopener">http://localhost/category/id/1111</a> 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Nginx服务&quot;&gt;&lt;a href=&quot;#Nginx服务&quot; class=&quot;headerlink&quot; title=&quot;Nginx服务&quot;&gt;&lt;/a&gt;Nginx服务&lt;/h2&gt;&lt;h2 id=&quot;Nginx现状&quot;&gt;&lt;a href=&quot;#Nginx现状&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="nginx" scheme="http://www.baidu.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://www.baidu.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>python设计模式</title>
    <link href="http://www.baidu.com/2019/05/06/python_design_pattern/"/>
    <id>http://www.baidu.com/2019/05/06/python_design_pattern/</id>
    <published>2019-05-05T19:27:52.000Z</published>
    <updated>2019-05-05T11:31:54.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="七大设计原则"><a href="#七大设计原则" class="headerlink" title="七大设计原则"></a>七大设计原则</h2><p>七大设计原则： </p><ul><li>1、单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】：一个类负责一项职责. </li><li>2、里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】：继承与派生的规则.（子类可替换父类） </li><li>3、依赖倒转原则【DEPENDENCE INVERSION PRINCIPLE】：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。 </li><li>4、接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 </li><li>5、迪米特法则【LOW OF DEMETER】：高内聚 低耦合 – high cohesion low coupling </li><li>6、开闭原则【OPEN CLOSE PRINCIPLE】：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 </li><li>7、组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】：尽量使用组合和聚合少使用继承的关系来达到复用的原则。</li></ul><h2 id="二十四种模式"><a href="#二十四种模式" class="headerlink" title="二十四种模式"></a>二十四种模式</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><ul><li>1、抽象工厂模式(Abstract factory pattern): 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要指定具体类. </li><li>2、生成器模式(Builder pattern): 使用生成器模式封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示. </li><li>3、工厂模式(factory method pattern): 定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类. </li><li>4、原型模式(prototype pattern): 当创建给定类的实例过程很昂贵或很复杂时, 就使用原形模式. </li><li>5、单例了模式(Singleton pattern): 确保一个类只有一个实例, 并提供全局访问点. </li><li>6、多例模式(Multition pattern): 在一个解决方案中结合两个或多个模式, 以解决一般或重复发生的问题. </li></ul><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><ul><li>1、适配器模式(Adapter pattern): 将一个类的接口, 转换成客户期望的另一个接口. 适配器让原本接口不兼容的类可以合作无间. 对象适配器使用组合, 类适配器使用多重继承. </li><li>2、桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变. </li><li>3、组合模式(composite pattern): 允许你将对象组合成树形结构来表现”整体/部分”层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合. </li><li>4、装饰者模式(decorator pattern): 动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案. </li><li>5、外观模式(facade pattern): 提供了一个统一的接口, 用来访问子系统中的一群接口. 外观定义了一个高层接口, 让子系统更容易使用. </li><li>6、亨元模式(Flyweight Pattern): 如想让某个类的一个实例能用来提供许多”虚拟实例”, 就使用蝇量模式. </li><li>7、代理模式(Proxy pattern): 为另一个对象提供一个替身或占位符以控制对这个对象的访问. </li></ul><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><ul><li>1、责任链模式(Chain of responsibility pattern): 通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象. </li><li>2、命令模式(Command pattern): 将”请求”封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作. </li><li>3、解释器模式(Interpreter pattern): 使用解释器模式为语言创建解释器. </li><li>4、迭代器模式(iterator pattern): 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示. </li><li>5、中介者模式(Mediator pattern) : 使用中介者模式来集中相关对象之间复杂的沟通和控制方式. </li><li>6、备忘录模式(Memento pattern): 当你需要让对象返回之前的状态时(例如, 你的用户请求”撤销”), 你使用备忘录模式. </li><li>7、观察者模式(observer pattern): 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新. </li><li>8、状态模式(State pattern): 允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类. </li><li>9、策略模式(strategy pattern): 定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户. </li><li>10、模板方法模式(Template pattern): 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤. </li><li>11、访问者模式(visitor pattern): 当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式.</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><pre><code>https://blog.csdn.net/weixin_41781973/article/details/80630337https://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#4130080https://www.cnblogs.com/Liqiongyu/p/5916710.html https://github.com/w392807287/Design_pattern_of_python</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;七大设计原则&quot;&gt;&lt;a href=&quot;#七大设计原则&quot; class=&quot;headerlink&quot; title=&quot;七大设计原则&quot;&gt;&lt;/a&gt;七大设计原则&lt;/h2&gt;&lt;p&gt;七大设计原则： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、单一职责原则【SINGLE RESPONSIBILITY P
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LVS</title>
    <link href="http://www.baidu.com/2019/04/18/LVS/"/>
    <id>http://www.baidu.com/2019/04/18/LVS/</id>
    <published>2019-04-18T15:22:43.000Z</published>
    <updated>2019-05-05T07:30:06.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h1><p>LVS(linux virtual server)即linux虚拟服务器，是一个虚拟的服务器集群系统。</p><p>使用集群技术和Linux操作系统实现一个高性能,高可用的服务器,很好的可伸缩性(scalability),很好的可靠性(reliability),很好的可管理性(manageability).</p><p>contos7:</p><p>grep -i ipvs /boot/config-3.10.0-693.e17.x86_64</p><p>grep -i ipvs -C 10 /boot/config-3.10.0-693.e17.x86_64</p><p>yum install ipvsadm</p><p>rpm -ql ipvsadm</p><p>curl命令</p><p>lvs服务器:<br>需要两块网卡</p><p>启用Ipforward：</p><pre><code>echo net.ipv4.ip_forward=1 &gt;&gt; /etc/sysctl.conf</code></pre><p>sysctl -p</p><p>sysctl -a | grep ip_forward</p><p>iptables -vnl</p><p>client：<br>需要桥接</p><p>RS1：<br>设置网关</p><pre><code>yum install httpdecho RS1 &gt; /var/www/html/index.html</code></pre><p>RS2；<br>设置网关</p><pre><code>yum install httpdecho RS2 &gt; /var/www/html/index.html</code></pre><p>LVS：</p><p>定义ipvs规则:NAt模式</p><pre><code>yum install ipvsadmipvsadm -A -t 172.20.0.200:80 -s rripvsadm -Lnipvsadm -a -t 172.20.0.200:80  -r 192.168.80.17 -mipvsadm -a -t 172.20.0.200:80  -r 192.168.80.27 -mipvsadm -Ln</code></pre><p>并发4百万 apache 1万</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="Cluster概念"><a href="#Cluster概念" class="headerlink" title="Cluster概念"></a>Cluster概念</h3><ul><li><p>系统扩展方式：</p><pre><code>scale up: 向上扩展，增强scale out: 向外扩展，增加设备，调度分配问题， cluster</code></pre></li><li><p>Cluster: 集群，未解决某个特定问题将多台计算机组合起来形成的单个系统</p></li><li><p>Linux Cluster类型：<br>  LB：load blancing, 负载均衡<br>  HA：high availiablity, 高可用， spof(single point of failure)</p><pre><code>MTBF: Mean Time Between Failure 平均无故障时间MTTR: Mean Time To REStoration (repair) 平均恢复前时间（故障时间）A=MTBF/(MTBF+MTTR) (0,1): 99%,99.5%, 99.9%, 99.99%, 99.999%</code></pre><p>  HPC: high-performance computing . 高性能 <a href="http://www.top500.org" target="_blank" rel="noopener">www.top500.org</a></p></li><li>分布式系统：<pre><code>分布式存储： 云盘分布式计算： hadoop, spark</code></pre></li></ul><h3 id="Cluster分类"><a href="#Cluster分类" class="headerlink" title="Cluster分类"></a>Cluster分类</h3><ul><li>LB Cluster的实现</li><li>硬件：<pre><code>F5 big-ipcitrix netscalerA10 A10</code></pre></li><li>软件:<pre><code>lvs: linux virtual servernginx: 支持七层调度haproxy: 支持七层调度ats: apache trafficserverperlbal: perl编写pound</code></pre></li><li>基于工作的协议层划分：</li><li>传输层（通用）：DPORT<br>  LVS：<br>  nginx：stream<br>  haproxy: mode tcp</li><li><p>应用层（专用）：针对特定协议，自定义的请求模型分类<br>  proxy server：</p><pre><code>http:nginx, httpdm haproxy(mode http),...fastcgi: nginx, httpd, ...mysql: mysql-proxy,...</code></pre></li><li><p>会话保持：负载均衡</p><pre><code>（1）session sticky: 同一用户调度固定服务器    source ip: lvs sh算法（对某一特定服务而言）    cookie（2）session replication: 每台服务器拥有全部session        session multicast cluster（3）session server: 专门的session服务器            memcached， redis</code></pre></li><li>HA集群实现方案<br>  keepalived: vrrp协议<br>  ais：应用接口规范<pre><code>heartbeatcman + rgmanager(RHCS)coresync_pacemaker</code></pre></li></ul><h2 id="LVS介绍"><a href="#LVS介绍" class="headerlink" title="LVS介绍"></a>LVS介绍</h2><h3 id="LVS介绍-1"><a href="#LVS介绍-1" class="headerlink" title="LVS介绍"></a>LVS介绍</h3><ul><li>LVS: linux virtual server, 负载调度器，集成内核<br>  官网：<a href="http://www.linuxvirtualserver.org/" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/</a><br>  VS：virtual server，负责调度<br>  RS：real server,负责真正提供服务<br>  L4：四层路由器或交换机</li><li>工作原理：vs根据请求报文的目标ip和目标协议及端口将其调度转发至某RS，根据调度算法来挑选RS</li><li>iptables/netfilter:<br>  iptables:用户空间的管理工具<br>  netfilter:内核空间上的框架<br>  流入：PREROUTING–&gt;INPUT<br>  流出：OUTPUT–&gt; POSTROUTING<br>  转发：PREROUTING–&gt;FORWARD–&gt;POSTROUTING<br>  DNAT：目标地址转换；PREROUTING</li></ul><h3 id="LVS概念"><a href="#LVS概念" class="headerlink" title="LVS概念"></a>LVS概念</h3><ul><li><p>lvs集群类型中的术语：<br>  VS：virtual server, director server(DS)</p><pre><code>dispatcher(调度器)，load balancer</code></pre><p>  RS:real server(lvs), upstream server(nginx)</p><pre><code>backend server(haproxy)</code></pre><p>  CIP:client ip<br>  VIP:virtual serve ip  VS外网的ip<br>  DIP:director ip  VS内网Ip<br>  RIP:real server ip</p><p>  访问流程：CIP<-->VIP==DIP<-->RIP</--></--></p></li></ul><h3 id="LVS集群的类型"><a href="#LVS集群的类型" class="headerlink" title="LVS集群的类型"></a>LVS集群的类型</h3><ul><li><p>lvs: ipvsadm/ipvs<br>  ipvsadm: 用户空间的命令行工具，规则管理器<br>  ipvs: 工作于内核空间netfilter的INPUT钩子上的框架</p></li><li><p>lvs集群的类型：<br>  lvs-nat: 修改请求报文的目标IP，多目标IP的DNAT<br>  lvs-dr: 操纵封装新的MAC地址<br>  lvs-tun: 在原请求IP报文之外新加一个IP首部<br>  lvs-fullnat: 修改请求报文的源和目标IP</p></li></ul><h3 id="lvs-nat模式"><a href="#lvs-nat模式" class="headerlink" title="lvs-nat模式"></a>lvs-nat模式</h3><ul><li>lvs-nat:<br>  本质是多目标IP的DNAT，通过将请求报文中的目标地址和目标端口修改为某挑出的RS的RIP和PORT实现转发<br>  (1)RIP和DIP应在同一个IP网络，且应使用私网地址，RS的网关要指向DIP<br>  (2)请求报文和响应报文都必须经由Director转发，Director易于成为系统瓶颈<br>  (3)支持端口映射，可修改请求报文的目标PORT<br>  (4)VS必须是linux系统，RS可以是任意OS系统</li></ul><h3 id="lvs-fullnat模式"><a href="#lvs-fullnat模式" class="headerlink" title="lvs-fullnat模式"></a>lvs-fullnat模式</h3><ul><li>lvs-fullnat:<br>  通过同时修改请求报文的源IP地址和目标IP地址进行转发<pre><code>CIP--&gt;DIPVIP--&gt;RIP</code></pre>  (1)VIP是公网地址，RIP和DIP是私网地址，且通常不在同一IP网络；因此。RIP的网关一般不会指向DIP<br>  (2)RS收到的请求报文源地址是DIP，因此，只需响应给DIP；但Director还要将其发往Client<br>  (3)请求和响应报文都经由Director<br>  (4)支持端口映射<br>  注意：此类型kernel默认不支持</li></ul><h3 id="LVS工作模式总结"><a href="#LVS工作模式总结" class="headerlink" title="LVS工作模式总结"></a>LVS工作模式总结</h3><table><thead><tr><th></th><th>VS/NAT</th><th>VS/TUN</th><th>VS/DR</th></tr></thead><tbody><tr><td>server</td><td>any</td><td>tunneling</td><td>non-arp device</td></tr><tr><td>server network</td><td>private</td><td>LAN/WAN</td><td>LAN</td></tr><tr><td>server number</td><td>low(10~20)</td><td>high(100)</td><td>high(100)</td></tr><tr><td>server gateway</td><td>load balancer</td><td>own router</td><td>own router</td></tr></tbody></table><ul><li><p>lvs-nat与lvs-fullnat:请求和响应报文都经由director<br>  lvs-nat:RIP的网关要指向DIP<br>  lvs-fullnat：RIP和DIP未必在同一IP网络，但要能通信</p></li><li><p>lvs-dr与lvs-tun:请求报文要经由director，但相应报文有RS直接发往client<br>  lvs-dr：通过封装新的MAC首部实现，通过MAC网络转发<br>  lvs-tun: 通过在院IP报文外封装新IP头实现转发，支持远距离通信</p></li></ul><h3 id="ipvs-scheduler"><a href="#ipvs-scheduler" class="headerlink" title="ipvs scheduler"></a>ipvs scheduler</h3><ul><li>ipvs scheduler:<br>  根据其调度时是否考虑各RS当前的负载状态<br>  两种：静态方法和动态方法</li><li><p>静态方法：仅根据算法本身进行调度</p><pre><code>1. RR: roundrobin,轮询2. WRR: weighted RR,加权轮询3. SH: source hashing,实现session sticky，源IP地址hash；将来自同一个IP地址的请求，始终发往第一次挑中的RS，从而实现会话绑定4. DH: destination hashing, 目标地址哈希，将发往同一个目标地址的骑牛始终发至第一次挑中的RS，典型使用场景是正向代理缓存场景中的负载均衡；如：宽带运行商</code></pre></li><li><p>动态方法：<br>  主要根据每个RS当前的负载状态及调度算法进行调度overhead=value较小的RS将被调度</p><ol><li>LC: least connections 适用于长连接应用<br> overhead=activeconns*256+inactiveconns</li><li>WLC: weighted LC,默认调度方法<br> overhead=(acticeconns*256+inactiveconns)/weight</li><li>SED: shortest expection delay,初始连接高权重优先<br> overhead=(activeconns+1)*256/weight</li><li>NQ: never queue, 第一轮均匀分配，后续sed</li><li>LBLC: locality-based LC，动态的DH算法，使用场景：根据负载状态实现正向代理</li><li>LBLCR: LBLC with replication, 带复制功能的LBLC，解决LBLC负载不均衡问题，从负载重的复制到负载轻的RS</li></ol></li></ul><h3 id="ipvsadm命令"><a href="#ipvsadm命令" class="headerlink" title="ipvsadm命令"></a>ipvsadm命令</h3><ul><li>ipvsadm 命令：</li><li><p>核心功能：</p><pre><code>集群服务管理：增，删，改集群服务的RS管理：增，删，改查看</code></pre><p>  ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] [-M netmask] [–pe persistence_engine] [-b sched-flags]<br>  ipvsadm -D -t|u|f service-address 删除<br>  ipvsadm -C 清空<br>  ipvsadm -R 重载<br>  ipvsadm -S [-n] 保存<br>  ipvsadm -a|e -t|u|f service-address -r server-address [options]<br>  ipvsadm -d -t|u|f service-address -r server-address<br>  ipvsadm -L|l [options]<br>  ipvsadm -Z [-t|U|f service-address]</p></li><li><p>管理集群上的RS：增，删，改</p></li><li>增、改：ipvsadm -a|e -t|u|f service-address -r server-address [-g|i|m]  [-w weight]</li><li>删：ipvsadm -d -t|u|f service-address -r server-address</li><li>server-addres:<br>  rip[:port] 如省略port，不作端口映射</li><li>选项：<br>  lvs类型:<pre><code>-g: gateway, dr类型，默认-i: ipip，tun类型-m: masquerade, nat类型</code></pre>  -w weight: 权重</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.sina.com.cn/s/blog_6786545e0102vjvq.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6786545e0102vjvq.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LVS&quot;&gt;&lt;a href=&quot;#LVS&quot; class=&quot;headerlink&quot; title=&quot;LVS&quot;&gt;&lt;/a&gt;LVS&lt;/h1&gt;&lt;p&gt;LVS(linux virtual server)即linux虚拟服务器，是一个虚拟的服务器集群系统。&lt;/p&gt;
&lt;p&gt;使用集群技术和
      
    
    </summary>
    
      <category term="lvs" scheme="http://www.baidu.com/categories/lvs/"/>
    
    
      <category term="lvs" scheme="http://www.baidu.com/tags/lvs/"/>
    
  </entry>
  
  <entry>
    <title>django集成celery</title>
    <link href="http://www.baidu.com/2019/04/18/django_celery/"/>
    <id>http://www.baidu.com/2019/04/18/django_celery/</id>
    <published>2019-04-17T19:22:43.000Z</published>
    <updated>2019-05-05T12:39:42.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Django集成Celery到项目"><a href="#Django集成Celery到项目" class="headerlink" title="Django集成Celery到项目"></a>Django集成Celery到项目</h2><p>将celery集成到Django项目中，实现异步任务处理和定时任务处理</p><h2 id="Celery工作流程"><a href="#Celery工作流程" class="headerlink" title="Celery工作流程"></a>Celery工作流程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/04/18/django_celery/django/celery.png" alt="celery流程图" title>                </div>                <div class="image-caption">celery流程图</div>            </figure><p>Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。</p><p><strong>消息中间件</strong></p><p>Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，RabbitMQ, Redis, MongoDB (experimental), Amazon SQS (experimental),CouchDB (experimental), SQLAlchemy (experimental),Django ORM (experimental), IronMQ</p><p><strong>任务执行单元</strong></p><p>Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。</p><p><strong>任务结果存储</strong></p><p>Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, Redis，memcached, MongoDB，SQLAlchemy, Django ORM，Apache Cassandra, IronCache</p><h2 id="1-Celery安装与配置"><a href="#1-Celery安装与配置" class="headerlink" title="1.Celery安装与配置"></a>1.Celery安装与配置</h2><p>在虚拟环境中安装:</p><pre><code>pip install django-celery==3.2.2pip install  django-redispip install flower   # celery  的web管理平台(异步任务可视化)</code></pre><p>查看集成到Django中的celery版本， pip  freeze</p><p> celery==3.1.26.post2      django-celery==3.2.2    flower==0.9.2</p><p>启动redis服务， 端口假设为6379</p><p>发现pip安装比较慢的情况</p><p>pip  install pillow  -i  <a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a>    </p><h2 id="2-Django中配置"><a href="#2-Django中配置" class="headerlink" title="2.Django中配置"></a>2.Django中配置</h2><h3 id="（1）在主工程的配置文件settings-py-中应用注册表INSTALLED-APPS中加入-djcelery"><a href="#（1）在主工程的配置文件settings-py-中应用注册表INSTALLED-APPS中加入-djcelery" class="headerlink" title="（1）在主工程的配置文件settings.py 中应用注册表INSTALLED_APPS中加入 djcelery"></a>（1）在主工程的配置文件settings.py 中应用注册表INSTALLED_APPS中加入 djcelery</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &apos;django.contrib.admin&apos;,</span><br><span class="line">    &apos;django.contrib.auth&apos;,</span><br><span class="line">    &apos;django.contrib.contenttypes&apos;,</span><br><span class="line">    &apos;django.contrib.sessions&apos;,</span><br><span class="line">    &apos;django.contrib.messages&apos;,</span><br><span class="line">    &apos;django.contrib.staticfiles&apos;,</span><br><span class="line">    &apos;art&apos;,</span><br><span class="line">    &apos;xadmin&apos;,</span><br><span class="line">    &apos;crispy_forms&apos;,</span><br><span class="line">    &apos;DjangoUeditor&apos;,</span><br><span class="line">    &apos;djcelery&apos;,       #加入djcelery</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="2-在settings-py-中加入celery配置信息"><a href="#2-在settings-py-中加入celery配置信息" class="headerlink" title="(2) 在settings.py 中加入celery配置信息"></a>(2) 在settings.py 中加入celery配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># celery 配置信息 start</span><br><span class="line"></span><br><span class="line">import djcelery</span><br><span class="line">djcelery.setup_loader()</span><br><span class="line">BROKER_URL = &apos;redis://127.0.0.1:6379/1&apos;</span><br><span class="line">CELERY_IMPORTS = (&apos;art.tasks&apos;)</span><br><span class="line">CELERY_TIMEZONE = &apos;Asia/Shanghai&apos;</span><br><span class="line">CELERYBEAT_SCHEDULER = &apos;djcelery.schedulers.DatabaseScheduler&apos; </span><br><span class="line">from celery.schedules import crontab</span><br><span class="line">from celery.schedules import timedelta</span><br><span class="line"></span><br><span class="line">CELERYBEAT_SCHEDULE = &#123;    #定时器策略</span><br><span class="line">    #定时任务一：　每隔30s运行一次</span><br><span class="line">    u&apos;测试定时器1&apos;: &#123;</span><br><span class="line">        &quot;task&quot;: &quot;art.tasks.tsend_email&quot;,</span><br><span class="line">        #&quot;schedule&quot;: crontab(minute=&apos;*/2&apos;),  # or &apos;schedule&apos;:   timedelta(seconds=3),</span><br><span class="line">        &quot;schedule&quot;:timedelta(seconds=30),</span><br><span class="line">        &quot;args&quot;: (),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># celery 配置信息 end</span><br></pre></td></tr></table></figure><p>​      当djcelery.setup_loader()运行时，Celery便会去查看INSTALLD_APPS下包含的所有app目录中的tasks.py文件，找到标记为task的方法，将它们注册为celery task</p><p>​     BROKER_URL：broker是代理人，它负责分发任务给worker去执行。我使用的是Redis作为broker</p><p>​    没有设置 CELERY_RESULT_BACKEND，默认没有配置，此时Django会使用默认的数据库(也是你指定的orm数据库)。</p><p>   CELERY_IMPORTS：是导入目标任务文件</p><p>   CELERYBEAT_SCHEDULER：使用了django-celery默认的数据库调度模型,任务执行周期都被存在默认指定的orm数据库中．</p><p>  CELERYBEAT_SCHEDULE：设置定时的时间配置， 可以精确到秒，分钟，小时，天，周等。</p><h3 id="（3）创建应用实例"><a href="#（3）创建应用实例" class="headerlink" title="（3）创建应用实例"></a>（3）创建应用实例</h3><p>​在主工程目录添加celery.py， 添加自动检索django工程tasks任务</p><p>​vim  artproject/celery.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># encoding: utf-8  </span><br><span class="line">#目的是拒绝隐士引入，celery.py和celery冲突。</span><br><span class="line">from __future__ import absolute_import,unicode_literals </span><br><span class="line">import os</span><br><span class="line">from celery import Celery</span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line"># 设置环境变量</span><br><span class="line">os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;artproject.settings&quot;)</span><br><span class="line"></span><br><span class="line">#创建celery应用</span><br><span class="line">app = Celery(&apos;art_project&apos;)</span><br><span class="line">app.config_from_object(&apos;django.conf:settings&apos;)</span><br><span class="line"></span><br><span class="line">#如果在工程的应用中创建了tasks.py模块，那么Celery应用就会自动去检索创建的任务。比如你添加了一个任#务，在django中会实时地检索出来。</span><br><span class="line">app.autodiscover_tasks(lambda :settings.INSTALLED_APPS)</span><br></pre></td></tr></table></figure><h3 id="4-创建任务-tasks"><a href="#4-创建任务-tasks" class="headerlink" title="(4) 创建任务 tasks"></a>(4) 创建任务 tasks</h3><p>每个任务本质上就是一个函数，在tasks.py中，写入你想要执行的函数即可。</p><p>在应用art中添加我们需要提供的异步服务和定时服务 </p><p> vim art/tasks.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># encoding: utf-8  </span><br><span class="line">from __future__ import absolute_import</span><br><span class="line">import time</span><br><span class="line">from django.core.mail import send_mail</span><br><span class="line">from celery.utils.log import get_task_logger</span><br><span class="line">from artproject.celery import app</span><br><span class="line"></span><br><span class="line">from art.utils.send_mail import pack_html, send_email</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def tsend_email():</span><br><span class="line">   url = &quot;http://1000phone.com&quot;</span><br><span class="line">   receiver = &apos;diyuhuan@1000phone.com&apos;</span><br><span class="line">   content = pack_html(receiver, url)</span><br><span class="line">   # content = &apos;this is email content.&apos;</span><br><span class="line">   send_email(receiver, content)</span><br><span class="line">   print(&apos;send email ok!&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def add(x, y):</span><br><span class="line">   return x+y</span><br></pre></td></tr></table></figure><p>上述我们把异步处理任务add和定时器任务tsend_email都放在了tasks.py 中</p><h3 id="（5）迁移生成celery需要的数据表"><a href="#（5）迁移生成celery需要的数据表" class="headerlink" title="（5）迁移生成celery需要的数据表"></a>（5）迁移生成celery需要的数据表</h3><pre><code>python   manage.py   migrate</code></pre><p>此时数据库表结构多出了几个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">celery_taskmeta            |</span><br><span class="line">| celery_tasksetmeta         |</span><br><span class="line">| djcelery_crontabschedule   |</span><br><span class="line">| djcelery_intervalschedule  |</span><br><span class="line">| djcelery_periodictask      |</span><br><span class="line">| djcelery_periodictasks     |</span><br><span class="line">| djcelery_taskstate         |</span><br><span class="line">| djcelery_workerstate</span><br></pre></td></tr></table></figure><h2 id="3-启动服务，测试"><a href="#3-启动服务，测试" class="headerlink" title="3.启动服务，测试"></a>3.启动服务，测试</h2><p>我们可以采用 python manage.py  help  发现多出了 celery 相关选项。 </p><h3 id="（1）启动django-celery-服务"><a href="#（1）启动django-celery-服务" class="headerlink" title="（1）启动django celery 服务"></a>（1）启动django celery 服务</h3><p>启动服务：</p><pre><code>python manage.py  celery   worker    --loglevel=info</code></pre><p>此时异步处理和定时处理服务都已经启动了</p><h3 id="（2）web端接口触发异步任务处理"><a href="#（2）web端接口触发异步任务处理" class="headerlink" title="（2）web端接口触发异步任务处理"></a>（2）web端接口触发异步任务处理</h3><p>我们在web端加入一个入口，触发异步任务处理add函数 </p><p>在应用art的urls.py 中加入如下对应关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from art.views import add_handler</span><br><span class="line"></span><br><span class="line">url(r&apos;^add&apos;, add_handler),</span><br></pre></td></tr></table></figure><p>art/views.py 中加入处理逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def add_handler(request):</span><br><span class="line">   x = request.GET.get(&apos;x&apos;, &apos;1&apos;)</span><br><span class="line">   y = request.GET.get(&apos;y&apos;, &apos;1&apos;)</span><br><span class="line">   from .tasks import add</span><br><span class="line">   add.delay(int(x), int(y))</span><br><span class="line">   res = &#123;&apos;code&apos;:200, &apos;message&apos;:&apos;ok&apos;, &apos;data&apos;:[&#123;&apos;x&apos;:x, &apos;y&apos;:y&#125;]&#125;</span><br><span class="line">   return HttpResponse(json.dumps(res))</span><br></pre></td></tr></table></figure><p>启动web服务，通过url传入的参数，通过handler的add.delay(x, y)计算并存入mysql</p><p><a href="http://127.0.0.1:8000/art/add?x=188&amp;y=22" target="_blank" rel="noopener">http://127.0.0.1:8000/art/add?x=188&amp;y=22</a></p><h3 id="4-测试定时器，发送邮件"><a href="#4-测试定时器，发送邮件" class="headerlink" title="(4)测试定时器，发送邮件"></a>(4)测试定时器，发送邮件</h3><p>在终端输入  python manage.py celerybeat -l info</p><p>会自动触发每隔30s执行一次tsend_email定时器函数，发送邮件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CELERYBEAT_SCHEDULE = &#123;    #定时器策略</span><br><span class="line">    #定时任务一：　每隔30s运行一次</span><br><span class="line">    u&apos;测试定时器1&apos;: &#123;</span><br><span class="line">        &quot;task&quot;: &quot;art.tasks.tsend_email&quot;,</span><br><span class="line">        #&quot;schedule&quot;: crontab(minute=&apos;*/2&apos;),  # or &apos;schedule&apos;: timedelta(seconds=3),</span><br><span class="line">        &quot;schedule&quot;:timedelta(seconds=30),</span><br><span class="line">        &quot;args&quot;: (),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体发送邮件服务程序见下面的第4节</p><h2 id="4-邮件发送服务"><a href="#4-邮件发送服务" class="headerlink" title="4.邮件发送服务"></a>4.邮件发送服务</h2><p>项目中经常会有定时发送邮件的情形，比如发送数据报告，发送异常服务报告等。</p><p>可以编辑文件 art/utils/send_mail.py, 内容编辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">#written by diyuhuan</span><br><span class="line">#发送邮件(wd_email_check123账号用于内部测试使用，不要用于其他用途)</span><br><span class="line"></span><br><span class="line">import smtplib  </span><br><span class="line">from email.mime.multipart import MIMEMultipart  </span><br><span class="line">from email.mime.text import MIMEText  </span><br><span class="line">from email.mime.image import MIMEImage </span><br><span class="line">from email.header import Header</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">sender = &apos;wd_email_check123@163.com&apos;  </span><br><span class="line">subject = u&apos;api开放平台邮箱验证&apos;</span><br><span class="line">smtpserver = &apos;smtp.163.com&apos;</span><br><span class="line">username = &apos;wd_email_check123&apos;</span><br><span class="line">password = &apos;wandacheck1234&apos;</span><br><span class="line">mail_postfix=&quot;163.com&quot;</span><br><span class="line"></span><br><span class="line">def send_email(receiver, content):</span><br><span class="line">    try:</span><br><span class="line">        me = username+&quot;&lt;&quot;+username+&quot;@&quot;+mail_postfix+&quot;&gt;&quot;</span><br><span class="line">        msg = MIMEText(content, &apos;html&apos;, &apos;utf-8&apos;)</span><br><span class="line">        msg[&apos;Subject&apos;] = subject</span><br><span class="line">        msg[&apos;From&apos;] = sender</span><br><span class="line">        msg[&apos;To&apos;] = receiver</span><br><span class="line">        smtp = smtplib.SMTP()  </span><br><span class="line">        smtp.connect(smtpserver)  </span><br><span class="line">        smtp.login(username, password)</span><br><span class="line">        smtp.sendmail(sender, receiver, msg.as_string())  </span><br><span class="line">        smtp.quit()</span><br><span class="line">        return True</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&apos;send_email has error with : &apos; + str(e))</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pack_html(receiver, url):</span><br><span class="line">    html_content = u&quot;&lt;html&gt;&lt;div&gt;尊敬的用户&lt;font color=&apos;#0066FF&apos;&gt;%s&lt;/font&gt; 您好！&lt;/div&gt;&lt;br&gt;&quot; \</span><br><span class="line">                   &quot;&lt;div&gt;感谢您关注我们的平台 ，我们将为您提供最贴心的服务，祝您购物愉快。&lt;/div&gt;&lt;br&gt;&quot; \</span><br><span class="line">                   &quot;&lt;div&gt;点击以下链接，即可完成邮箱安全验证：&lt;/div&gt;&lt;br&gt;&quot;  \</span><br><span class="line">                   &quot;&lt;div&gt;&lt;a href=&apos;%s&apos;&gt;%s&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&quot;  \</span><br><span class="line">                   &quot;&lt;div&gt;为保障您的帐号安全，请在24小时内点击该链接; &lt;/div&gt;&lt;br&gt;&quot; \</span><br><span class="line">                   &quot;&lt;div&gt;若您没有申请过验证邮箱 ，请您忽略此邮件，由此给您带来的不便请谅解。&lt;/div&gt;&quot; \</span><br><span class="line">                   &quot;&lt;/html&gt;&quot; % (receiver, url, url)</span><br><span class="line">    html_content = html_content</span><br><span class="line">    return html_content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    url = &quot;http://1000phone.com&quot;</span><br><span class="line">    receiver = &apos;diyuhuan@1000phone.com&apos;</span><br><span class="line">    #content = pack_html(receiver, url)</span><br><span class="line">    content = &apos;this is email content. at %s.&apos;%int(time.time())</span><br><span class="line">    send_email(receiver,  content)</span><br></pre></td></tr></table></figure><p>至此，在celery ui界面可以看到两类，定时器处理和异步处理。</p><h2 id="5-启动flower服务"><a href="#5-启动flower服务" class="headerlink" title="5.启动flower服务"></a>5.启动flower服务</h2><pre><code>python manager celery flower</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Django集成Celery到项目&quot;&gt;&lt;a href=&quot;#Django集成Celery到项目&quot; class=&quot;headerlink&quot; title=&quot;Django集成Celery到项目&quot;&gt;&lt;/a&gt;Django集成Celery到项目&lt;/h2&gt;&lt;p&gt;将celery集成到
      
    
    </summary>
    
      <category term="django" scheme="http://www.baidu.com/categories/django/"/>
    
    
      <category term="django" scheme="http://www.baidu.com/tags/django/"/>
    
      <category term="celery" scheme="http://www.baidu.com/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>django中的日志处理</title>
    <link href="http://www.baidu.com/2019/04/18/django_logging/"/>
    <id>http://www.baidu.com/2019/04/18/django_logging/</id>
    <published>2019-04-17T19:22:43.000Z</published>
    <updated>2019-05-05T11:56:10.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Django中加入日志功能"><a href="#1-Django中加入日志功能" class="headerlink" title="1  Django中加入日志功能"></a>1  Django中加入日志功能</h2><p>Django 中使用python的 logging 模块记录log，在 Django 中使用 Django 提供的配制方法。就是在 settings 中通过变量 LOGGING，LOGGING 是一个字典，典型的配置如下：</p><p>​logging模块为应用程序提供了灵活的手段记录事件、错误、警告和调试信息。对这些信息可以进行收集、筛选、写入文件、发送给系统日志等操作，甚至还可以通过网络发送给远程计算机。</p><h3 id="（1）日志记录级别"><a href="#（1）日志记录级别" class="headerlink" title="（1）日志记录级别"></a>（1）日志记录级别</h3><p>​logging模块的重点在于生成和处理日志消息。每条消息由一些文本和指示其严重性的相关级别组成。级别包含符号名称和数字值。</p><table><thead><tr><th>级别</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>CRITICAL/FATAL</td><td>50</td><td>关键错误/消息</td></tr><tr><td>ERROR</td><td>40</td><td>错误</td></tr><tr><td>WARNING</td><td>30</td><td>警告消息</td></tr><tr><td>INFO</td><td>20</td><td>通知消息</td></tr><tr><td>DEBUG</td><td>10</td><td>调试</td></tr><tr><td>NOTSET</td><td>0</td><td>无级别</td></tr></tbody></table><h3 id="（2）记录器（日志对象-logging-getLogger-）-默认的root记录器"><a href="#（2）记录器（日志对象-logging-getLogger-）-默认的root记录器" class="headerlink" title="（2）记录器（日志对象-logging.getLogger()）-默认的root记录器"></a>（2）记录器（日志对象-logging.getLogger()）-默认的root记录器</h3><p>​记录器负责管理日志消息的默认行为，包括日志记录级别、输出目标位置、消息格式以及其它基本细节。</p><p>如下是处理器Handler关键的参数：</p><table><thead><tr><th>关键字参数</th><th>描述</th></tr></thead><tbody><tr><td>filename</td><td>将日志消息附加到指定文件名的文件</td></tr><tr><td>filemode</td><td>指定用于打开文件模式</td></tr><tr><td>format</td><td>用于生成日志消息的格式字符串</td></tr><tr><td>datefmt</td><td>用于输出日期和时间的格式字符串</td></tr><tr><td>level</td><td>设置记录器的级别</td></tr><tr><td>stream</td><td>提供打开的文件，用于把日志消息发送到文件。</td></tr></tbody></table><h3 id="（3）format-日志消息格式"><a href="#（3）format-日志消息格式" class="headerlink" title="（3）format 日志消息格式"></a>（3）format 日志消息格式</h3><p>​e.g.  ‘%(asctime)s  %(module)s  %(level)s  %(lineno)d’</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%(name)s</td><td>记录器的名称, 默认为root</td></tr><tr><td>%(levelno)s</td><td>数字形式的日志记录级别</td></tr><tr><td>%(levelname)s</td><td>日志记录级别的文本名称</td></tr><tr><td>%(filename)s</td><td>执行日志记录调用的源文件的文件名称</td></tr><tr><td>%(pathname)s</td><td>执行日志记录调用的源文件的路径名称</td></tr><tr><td>%(funcName)s</td><td>执行日志记录调用的函数名称</td></tr><tr><td>%(module)s</td><td>执行日志记录调用的模块名称</td></tr><tr><td>%(lineno)s</td><td>执行日志记录调用的行号</td></tr><tr><td>%(created)s</td><td>执行日志记录的时间</td></tr><tr><td>%(asctime)s</td><td>日期和时间</td></tr><tr><td>%(msecs)s</td><td>毫秒部分</td></tr><tr><td>%(thread)d</td><td>线程ID</td></tr><tr><td>%(threadName)s</td><td>线程名称</td></tr><tr><td>%(process)d</td><td>进程ID</td></tr><tr><td>%(message)s</td><td>记录的消息</td></tr></tbody></table><h3 id="（4）内置处理器"><a href="#（4）内置处理器" class="headerlink" title="（4）内置处理器"></a>（4）内置处理器</h3><p>​    logging模块提供了一些处理器，可以通过各种方式处理日志消息。使用addHandler()方法将这些处理器添加给Logger对象。另外还可以为每个处理器配置它自己的筛选和级别。</p><p>​      handlers.DatagramHandler(host，port):发送日志消息给位于制定host和port上的UDP服务器。</p><p>​      * handlers.FileHandler(filename): 将日志消息写入文件filename。</p><p>​      handlers.HTTPHandler(host, url):使用HTTP的GET或POST方法将日志消息上传到一台HTTP 服务器。</p><p>​      * handlers.RotatingFileHandler(filename):将日志消息写入文件filename。如果文件的大小超出maxBytes制定的值，那么它将被备份为filename1。</p><p>​    由于内置处理器还有很多，如果想更深入了解。可以查看官方手册。</p><h3 id="（5）python的日志简单地用法"><a href="#（5）python的日志简单地用法" class="headerlink" title="（5）python的日志简单地用法"></a>（5）python的日志简单地用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置日志等级</span></span><br><span class="line">logging.getLogger().setLevel(logging.INFO)</span><br><span class="line">formatter = <span class="string">'%(asctime)s: %(filename)s/%(funcName)s at %(lineno)s-&gt;%(message)s'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置日志的信息，filename 要指定日志输出的文件名</span></span><br><span class="line">logging.basicConfig(format=formatter,</span><br><span class="line">                    datefmt=<span class="string">'%Y-%m-%d %H:%M:%S'</span>,</span><br><span class="line">                    filename=<span class="string">'art.log'</span>,</span><br><span class="line">                    filemode=<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">logging.warning(<span class="string">'--当前页面要被缓存5秒---'</span>)</span><br></pre></td></tr></table></figure><h2 id="2-Django中使用日志"><a href="#2-Django中使用日志" class="headerlink" title="2  Django中使用日志"></a>2  Django中使用日志</h2><p>在Django的配置文件settings.py 中加入如下LOGGING配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Django Logging  BEGIN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#LOGGING_DIR 日志文件存放目录</span><br><span class="line">LOGGING_DIR = &quot;/home/xxt/logs&quot;</span><br><span class="line">if not os.path.exists(LOGGING_DIR):</span><br><span class="line">    os.mkdir(LOGGING_DIR)</span><br><span class="line"></span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">LOGGING = &#123;</span><br><span class="line">    &apos;version&apos;: 1,</span><br><span class="line">    &apos;disable_existing_loggers&apos;: False,</span><br><span class="line">    &apos;formatters&apos;: &#123;</span><br><span class="line">        &apos;standard&apos;: &#123;</span><br><span class="line">            &apos;format&apos;: &apos;[%(levelname)s][%(asctime)s][%(filename)s][%(funcName)s][%(lineno)d] &gt; %(message)s&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;simple&apos;: &#123;</span><br><span class="line">            &apos;format&apos;: &apos;[%(levelname)s]&gt; %(message)s&apos;,</span><br><span class="line">            &apos;datefmt&apos;: &apos;%Y-%m-%d %H:%M:%S&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;filters&apos;: &#123;</span><br><span class="line">        &apos;require_debug_true&apos;: &#123;</span><br><span class="line">            &apos;()&apos;: &apos;django.utils.log.RequireDebugTrue&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;handlers&apos;: &#123;</span><br><span class="line">        &apos;console&apos;: &#123;</span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;filters&apos;: [&apos;require_debug_true&apos;],</span><br><span class="line">            &apos;class&apos;: &apos;logging.StreamHandler&apos;,</span><br><span class="line">            &apos;formatter&apos;: &apos;simple&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;file_handler&apos;: &#123;</span><br><span class="line">             &apos;level&apos;: &apos;INFO&apos;,</span><br><span class="line">             &apos;class&apos;: &apos;logging.handlers.TimedRotatingFileHandler&apos;,</span><br><span class="line">             &apos;filename&apos;: &apos;%s/django.log&apos; % LOGGING_DIR,</span><br><span class="line">             &apos;formatter&apos;:&apos;standard&apos;,</span><br><span class="line">             &apos;encoding&apos;: &apos;utf-8&apos;</span><br><span class="line">        &#125;, # 用于文件输出</span><br><span class="line">        &apos;mail_admins&apos;: &#123;</span><br><span class="line">            &apos;level&apos;: &apos;ERROR&apos;,</span><br><span class="line">            &apos;class&apos;: &apos;django.utils.log.AdminEmailHandler&apos;,</span><br><span class="line">             &apos;formatter&apos;:&apos;standard&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;loggers&apos;: &#123;</span><br><span class="line">        &apos;mdjango&apos;: &#123;</span><br><span class="line">            &apos;handlers&apos;: [&apos;console&apos;,&apos;file_handler&apos;],</span><br><span class="line">            &apos;level&apos;:&apos;DEBUG&apos;,</span><br><span class="line">            &apos;propagate&apos;: True,</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;django.request&apos;: &#123;</span><br><span class="line">            &apos;handlers&apos;: [&apos;mail_admins&apos;],</span><br><span class="line">            &apos;level&apos;: &apos;ERROR&apos;,</span><br><span class="line">            &apos;propagate&apos;: False,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(&quot;mdjango&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Django Logging  END</span><br></pre></td></tr></table></figure><p>最新日志内容存入：  django.log</p><p>前一天：django.log.2018-05-29</p><p>前前一天：django.log.2018-05-28</p><p>django.log.2018-05-22</p><p>在具体的业务逻辑代码中加入日志记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from Project.settings import  logger</span><br><span class="line">logger.info(&quot;IndexHandler request Handler begin&quot;)</span><br><span class="line">logger.debug(&apos;query total:&apos; + str(total))</span><br></pre></td></tr></table></figure><p>观察日志打印情况。</p><p>一般python使用日志功能（非django框架）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">def logging_init():</span><br><span class="line">   app_name = &quot;AppName&quot;</span><br><span class="line">   log_file_name = &quot;myapp_test.log&quot;</span><br><span class="line">   logger = logging.getLogger(app_name)</span><br><span class="line">   format_str = &quot;[%(asctime)s][%(levelname)s]&gt; %(message)s&quot;</span><br><span class="line">   formatter = logging.Formatter(format_str)</span><br><span class="line">   file_handler = logging.FileHandler(log_file_name)</span><br><span class="line">   file_handler.setFormatter(formatter)</span><br><span class="line">   logger.addHandler(file_handler)</span><br><span class="line">   logger.setLevel(logging.INFO)</span><br><span class="line">   return logger</span><br></pre></td></tr></table></figure><p>单例模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">   _instance = None</span><br><span class="line"></span><br><span class="line">   def __new__(cls, *args, **kwargs):</span><br><span class="line">      if not cls._instance:</span><br><span class="line">         cls._instance = super(Singleton, cls).__new__(cls,</span><br><span class="line">                                    *args, **kwargs)</span><br><span class="line">      return cls._instance</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">app_name = &quot;appName&quot;</span><br><span class="line">log_file = &quot;test.log&quot;</span><br><span class="line"></span><br><span class="line">class SingletonLogger(Singleton):</span><br><span class="line"></span><br><span class="line">   def __init__(self):</span><br><span class="line">      super(SingletonLogger, self).__init__()</span><br><span class="line">      self.logger = logging.getLogger(app_name)</span><br><span class="line">      format_str = &quot;[%(asctime)s][%(levelname)s]&gt; %(message)s&quot;</span><br><span class="line">      formatter = logging.Formatter(format_str)</span><br><span class="line">      file_handler = logging.FileHandler(log_file)</span><br><span class="line">      file_handler.setFormatter(formatter)</span><br><span class="line">      self.logger.addHandler(file_handler)</span><br><span class="line">      self.logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line">   def debug(self, data):</span><br><span class="line">      self.logger.debug(data)</span><br><span class="line"></span><br><span class="line">   def info(self, data):</span><br><span class="line">      self.logger.info(data)</span><br><span class="line"></span><br><span class="line">   def warning(self, data):</span><br><span class="line">      self.logger.warning(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   def error(self, data):</span><br><span class="line">      self.logger.error(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def test_log():</span><br><span class="line">   logger = SingletonLogger()</span><br><span class="line">   #output the log msg</span><br><span class="line">   logger.debug(&quot;this is the debug message&quot;)</span><br><span class="line">   logger.info(&quot;this is the info message&quot;)</span><br><span class="line">   logger.warning(&quot;this is the warning message&quot;)</span><br><span class="line">   logger.error(&quot;this is the error message&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Django中加入日志功能&quot;&gt;&lt;a href=&quot;#1-Django中加入日志功能&quot; class=&quot;headerlink&quot; title=&quot;1  Django中加入日志功能&quot;&gt;&lt;/a&gt;1  Django中加入日志功能&lt;/h2&gt;&lt;p&gt;Django 中使用python
      
    
    </summary>
    
      <category term="django" scheme="http://www.baidu.com/categories/django/"/>
    
    
      <category term="django" scheme="http://www.baidu.com/tags/django/"/>
    
      <category term="log" scheme="http://www.baidu.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>hexo</title>
    <link href="http://www.baidu.com/2019/04/05/hexo/"/>
    <id>http://www.baidu.com/2019/04/05/hexo/</id>
    <published>2019-04-05T09:36:34.000Z</published>
    <updated>2019-05-05T07:57:02.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><table><thead><tr><th>文件/文件夹</th><th>说明</th></tr></thead><tbody><tr><td>_config.yml</td><td>配置文件</td></tr><tr><td>public</td><td>生成的静态文件，这个目录最终会发布到服务器</td></tr><tr><td>scaffolds</td><td>一些通用的markdown模板</td></tr><tr><td>source</td><td>编写的markdown文件，_drafts草稿文件，_posts发布的文章</td></tr><tr><td>themes</td><td>博客的模板</td></tr></tbody></table><p>常用命令</p><pre><code>hexo new &quot;postName&quot;hexo new page &quot;pageName&quot;hexo server</code></pre><hr><pre><code>npm install hexo-cli -ghexo init blogcd blognpm installhexo server</code></pre><p>创建一篇新的文章</p><pre><code>hexo new [layout] &lt;title&gt;</code></pre><p>hexo有三种默认的布局：post,page,draft他们分别对应的路径如下<br>|布局|路径|<br>|—|—|<br>|post|source/_posts|<br>|page|source|<br>|draft|source/_drafts|</p><h2 id="提交到github"><a href="#提交到github" class="headerlink" title="提交到github"></a>提交到github</h2><p>安装git插件</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>git的配置，修改_config.yml文件</p><pre><code>deploy:    type: git    repository: git@github.com:love-fengyuan/love-fengyuan.github.io.git    branch: master </code></pre><p>将代码push到github：</p><pre><code>hexo deploy</code></pre><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>执行deploy命令了，但是代码未上传？</p><pre><code>先执行hexo generate命令，生成静态文件了，再执行hexo deploy上传，上传是只会上传public中生成的文件。</code></pre><p>修改了模板，但是没有生效？</p><pre><code>修改了模板没有生效，建议先“hexo clean”，然后在“hexo generate”，只执行hexo generate，可能模板后者静态文件不会替换。</code></pre><h3 id="第二篇博客"><a href="#第二篇博客" class="headerlink" title="第二篇博客"></a>第二篇博客</h3><ol><li>hexo new title</li><li>修改显示路径，使用start路径来编辑它（如果是\斜杠需换成/斜杠）</li><li>hexo generate</li><li>hexo deploy</li><li>查看博客</li></ol><h2 id="插入图片视频"><a href="#插入图片视频" class="headerlink" title="插入图片视频"></a>插入图片视频</h2><p>插入图片</p><pre><code>![k8sss](test/k8s_jg.png)</code></pre><p>插入视频</p><pre><code>&lt;video href=&apos;test/roam_1.mp4&apos; type=&apos;video/mp4&apos; controls=&apos;controls&apos;  width=&apos;100%&apos; height=&apos;100%&apos;&gt;love&lt;/video&gt;{% raw %}    <video src="test/6a0250dbd55daf505801cf877c370626.mp4" type="video/mp4" controls="controls" width="100%" height="100%"></video>    {% endraw%}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><pre><code>官网：https://hexo.io/zh-cn/https://www.jianshu.com/p/da491b249aeehttps://www.jianshu.com/p/a7cc54797ecc</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件/文件夹&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;
      
    
    </summary>
    
      <category term="hexo" scheme="http://www.baidu.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.baidu.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>plan</title>
    <link href="http://www.baidu.com/2019/04/05/plan/"/>
    <id>http://www.baidu.com/2019/04/05/plan/</id>
    <published>2019-04-05T09:36:34.000Z</published>
    <updated>2019-05-03T17:52:52.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="plan"><a href="#plan" class="headerlink" title="plan"></a>plan</h1><p>Q:web压力测试工具</p><p>A:Apache JMeter // Web Application Stress Tool // gatling // locust</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>Mysql / Mongodb / Redis<br>Tomact  Nginx<br>Kubernetes / Docker<br>python shell<br>Ansible/ Puppet / SaltStack / Fabric<br>Zabbix/ Nagios / Cacti / Grafana / Prometheus / ELK /<br>Kafka</p><p>jenkins / gitlab /</p><p>Lvs / Haproxy<br>LAMP / LNMP/</p><p>DAS/SNA/NAS/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;plan&quot;&gt;&lt;a href=&quot;#plan&quot; class=&quot;headerlink&quot; title=&quot;plan&quot;&gt;&lt;/a&gt;plan&lt;/h1&gt;&lt;p&gt;Q:web压力测试工具&lt;/p&gt;
&lt;p&gt;A:Apache JMeter // Web Application Stress T
      
    
    </summary>
    
      <category term="plan other" scheme="http://www.baidu.com/categories/plan-other/"/>
    
    
      <category term="plan" scheme="http://www.baidu.com/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>ansible</title>
    <link href="http://www.baidu.com/2019/03/10/ansible/"/>
    <id>http://www.baidu.com/2019/03/10/ansible/</id>
    <published>2019-03-10T15:06:52.000Z</published>
    <updated>2019-05-05T07:25:07.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h1><h2 id="Ansible-基础"><a href="#Ansible-基础" class="headerlink" title="Ansible 基础"></a>Ansible 基础</h2><ol><li>ANSIBLE_CONFIG  环境变量，可以定义配置文件的位置</li><li>./ansible.cfg    存在于当前工作目录</li><li>~/.ansible.cfg   存在于当前用户家目录</li><li>/etc/ansible/ansible.cfg 默认目录</li></ol><h2 id="Ansible命令"><a href="#Ansible命令" class="headerlink" title="Ansible命令"></a>Ansible命令</h2><p>主机要求：<br>windows除外</p><p>配置语言：<br>    yaml，json<br>只有server</p><p>role:<br>ansible 可以重复使用的</p><p>Ansible:</p><p><a href="https://github.com/ansible/ansible" target="_blank" rel="noopener">https://github.com/ansible/ansible</a></p><p>从release下载安装包</p><p>需要pip安装包的依赖</p><p>log：</p><p><a href="https://www.cnblogs.com/xielisen/p/6817807.html" target="_blank" rel="noopener">https://www.cnblogs.com/xielisen/p/6817807.html</a></p><p>查看文件个数：<br>ls -l | grep ‘^-‘ | wc -l </p><p>##################################马哥 Ansible</p><p>文件传输<br>命令执行：应用部署，配置管理，任务流编排</p><p>企业应用场景：<br>开发，测试，发布，生产，灰度环境（基于主机，用户，地区）</p><p>vie0 修改主机ip</p><p>ansible -m ping<br>m:模块<br>ansible 127.0.0.1 -m ping</p><p>在 /etc/ansible/hosts中配置主机清单</p><p>测试网络通讯;</p><pre><code>ansible 192.168.1.101 -m ping -k </code></pre><p>输入口令（密码）<br>k: 密码认证<br>建议基于key验证</p><pre><code>etc/ssh/sshd_config  ansible all -m ping  </code></pre><p>all: 代表主机清单的所有主机</p><h2 id="ansible-cfg"><a href="#ansible-cfg" class="headerlink" title="ansible.cfg"></a>ansible.cfg</h2><p>ansible.cfg</p><pre><code>forks=5     并发执行5</code></pre><p>ansible-doc:显示模块命令</p><p>ansible websevers –list-hosts</p><p>ansible all –list-host</p><p>ansible debserver -m ping -u wang -k    以wang的身份去连接</p><p>ansible debserver -m command -a ‘ls /root’ -u wang -k -b -K<br>以wang身份连接，切换到root用户权限，默认为root -K root口令</p><p>usermod -a -G wheel wang 将wang加入到组</p><p>K的口令;<br>sudo中：取消下面一行的注释：<br>%wheel ALL=(ALL)    NOPASSWD:ALL</p><p>基于key验证</p><pre><code>ssh-keygenssh-copy-id 192.168.80.101ssh-copy-id 192.168.80.102.......</code></pre><p>&amp; linux中表示后台执行</p><p>ansible all -m command -a “sleep 10”<br>休眠10s</p><p>command:</p><p>ansible all -a ‘ls /data’</p><p>ansible all -a ‘df -h’</p><p>ansible-doc command</p><p>creates 存在不执行</p><p>ansible all -a ‘removes=/etc/fs cat /etc/fstab’</p><p>removes 不存在不执行</p><p>ansible all -a ‘creates=/etc/fs cat /etc/fstab’</p><p>chdir  切换文件夹</p><p>ansible all -a ‘chdir=/root ls’</p><p>ansible 192.168.80.101 -a ‘/data/test.sh’</p><p>执行该主机上/data/test.sh</p><p>注： 注意规范 #！/bin/bash</p><p>创建账号：</p><pre><code>ansible all -a &apos;useradd test1&apos;</code></pre><p>查询：</p><pre><code>ansible all -a &apos;getent passwd test1&apos;</code></pre><p>command 命令对管道，重定向,变量 特殊符号支持有问题，建议shell</p><p>shell：</p><pre><code>ansible all -m shell -a &apos;echo $HOSTNAME&apos;</code></pre><p>更改口令:</p><pre><code>ansible all -m shell -a &apos;echo magedu|passwd --stdin test1&apos;</code></pre><p>script：</p><p>chmod +x test.sh</p><p>ansible all -m script -a ‘/root/ansible/test.sh’<br>在所有主机上执行test.sh</p><p>ansible all -a ‘getenforce’</p><p>cp /etc/sysconfig/selinux &gt;<br>vim selinux </p><p>copy:<br>ansible-doc -s copy</p><p>ansible all -m copy -a ‘src=/root/ansible/selinux dest=/etc/selinux/config backup=yes’<br>文件复制</p><p>ansible all -m shell -a ‘getenforce’</p><p>ansible all -m copy -a ‘src=/etc/shadow dest=/data mode=000 owner=root’</p><p>ansible all -m copy -a ‘content=”hello\n thanks \n “ dest=/data/f2’<br>直接写内容生成文件</p><p>fetch：<br>从客户端去文件到服务器端，与copy相反</p><p>ansible all -m fetch -a ‘src=/var/log/messages dest=/data’<br>从远程主机抓取log/message,到服务器，仅限单个文件</p><p>ansible all -m shell -a ‘tar jcf log.tar.xz /var/log/*.log’</p><p>包的加压与解压<br>archive<br>unarchive</p><p>file：</p><p>ansible all -m file -a ‘name=/data/f3 state=touch’  创建文件</p><p>ansible all -m file -a ‘name=/data/f3 state=absent’ 删除文件</p><p>ansible all -a ‘ls -l /data’</p><p>ansible all -m file -a ‘name=/data/dir1 state=directory’    创建文件夹，’state=absent’ 删除</p><p>‘src=/etc/fstab dest=/data/fstab.link state=link’   创建软连接</p><p>‘dest=/data/fstab.link state=absent’    删除软连接</p><p>‘dest=/data/* state=absent’ 删除所有文件</p><p>‘dest=/data/ state=absent’  删除文件夹</p><p>不能删除挂载点上的</p><p>ansible 192.168.80.101 -m hostname -a ‘name=new_name’ 修改主机名</p><p>cron：</p><p>ansible all -m cron -a ‘minute=* weekday=1,3,5 job=”/usr/bin/wall FBI warning” name=warningcron’ 创建定时报警任务，写入crontab</p><p>ansible all -m cron -a ‘disabled=true job=”/usr/bin/wall FBI warning” name=warningcron’ 禁用此任务，必须加name</p><p>‘job=”/usr/bin/wall FBI warning” name=warningcron state=absent’ 删除</p><p>yum<br>/etc/yum.repos/base.repo yum仓库配置</p><p>ansible all -m yum -a ‘name=vsftpd’<br>安装<br>多个软件用’,’隔开</p><p>ansible all -m yun -a ‘list=instealled’ 安装过的列表</p><p>‘name=vsftpd state=removed’卸载</p><p>‘name=vsftpd state=absent’</p><p>‘rpm -q vsftpd’ 查找是否卸载</p><p>安装下载好的软件；<br>ansible all -m copy -a ‘src=/data/softname dest=/root/‘</p><p>ansible all -a ‘ls /root/‘</p><p>ansbile all -m yum -a ‘name=/root/softname’</p><p>disable_gpg_check=yes 忽略，禁用</p><p>‘name=dstat update_cache=yes’ 更新缓存</p><p>services:</p><p>ansible all -m services -a ‘name=vsftpd state=started enabled=yes’<br>启动服务，同时设为开机启动  </p><p>user:</p><p>ansible all -m user -a ‘name=nginx shell=/sbin/nologin system=yes home=/var/nginx groups=root,bin uid=80 comment=”nginx service”‘</p><p>创建账号</p><p>ansible all -m user -a ‘name=nginx state=absent remove=yes’ 删除账号，删除home目录</p><p>group:</p><p>ansible all -m group -a ‘name=nginx system=yes gid=80’</p><p>ansible all -a ‘getent group nginx’</p><p>ansible -m group -a ‘name=nginx state=absent’  删除</p><p>ansible-galaxy:</p><p>ansible-galaxy install geerlingguy.nginx</p><p>yml/yaml:</p><p>注意缩进，格式</p><pre><code>----hosts:webserverremote_user:roottasks:    -name:hello    command：hostname</code></pre><p>ansible-playbook test.yaml</p><p>ansible-vault:<br>ansible-vault encrypt test.yaml     对文件进行加密，避免敏感信息泄露</p><p>需要设置加密口令,再次执行yaml时会报错，</p><p>ansible-vault decrypt test.yaml     解密</p><p>ansible-vault view test.yaml   查看yaml需要输入口令</p><p>ansible-vault rekey test.yaml  修改密码</p><p>ansible-vault create test2.yaml     创建新的playbook文件</p><p>ansible-console:</p><p>交互式：<br>ansible-console</p><p>“root@all (3)[f:5]$ “ 并发数量为5也可以修改forks 10</p><p>cd 192.168.80.135  切换到135主机</p><p>hostname name=node2.magedu.com 修改主机名</p><h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>playbook采用YAMl语言编写</p><p>1.# test yaml 注释<br>2.缩进必须统一</p><pre><code>---- hosts:webserverremote_user:roottasks:    - name:create new file  #描述    file:name=/data/newfile state=touch   模块/命令    - name:create new user    user: name=test2     - name: install httpd    yum:name=httpd    - name:copy conf    copy:src=/etc/conf dest=/etc/conf    - name:start service    service:name=httpd state=started enables=yes</code></pre><p>ansible-playbook -C file.yml    # -C 检查</p><p>ansible all -a ‘getent passwd test2’    #查看test2用户</p><p>ansible all -m shell -a ‘ss -tln | grep :80’    #查看80端口</p><p>ansible all -a ‘getent passwd test2’ –limit 192.168.80.134</p><p>ansibel-playbook file.yml –list</p><p>ansibel-playbook file.yml –list-tasks</p><pre><code>- name:copy a filecopy:src=files/test.py dest=/etc/test.py  #files相对路径，相对于当前目录</code></pre><p>注：文件修改后再次执行copy，不会生效</p><p> 更新配置文件，执行playbook后，并不会生效</p><pre><code>http.yml---- hosts: webserverremote_user:roottasks:    - name:install https package    yum:name-httpd    - name: copy conf file    copy: src=files/httpd.conf dest=/etc/httpd/conf baskup=yes    - name: start service    service: name=httpd state=started enabled=yes</code></pre><p>执行http.yml，修改配置文件后，执行不会重启</p><pre><code>http.yml---- hosts: webserver  remote_user:root  tasks:    - name:install https package    yum:name-httpd    tag:inshttpd    - name: copy conf file    copy: src=files/httpd.conf dest=/etc/httpd/conf baskup=yes    notify:restart service    - name: start service    service: name=httpd state=started enabled=yes    tag:rshttpd  handlers:    - name: restart service      service: name=http state=restarted</code></pre><p>也可以同时触发两个任务</p><p>tags：</p><p>添加标签，可以单独执行标签</p><p>多个动作共用一个标签</p><p>ansible-playbook -t rshttpd httpd.yml</p><p>ansible-playbook -t inshttpd,rshttpd httpd.yml</p><p>setup:</p><p>ansible all -m setup -a ‘filter=ansible_hostname’</p><p>ansible all -m setup -a ‘filter=<em>address</em>‘\</p><p>ansible all -m setup -a ‘filter=ansible_all_ipv4_address’</p><pre><code>app.yml---- hosts: webserverremote_user: roottasks:    - name: install packing    yum: name={{ pkname }}    - name: start service    service: name={{ pkname }} state=started enabled=yes</code></pre><p>ansible-playbook -e ‘pkname=httpd’ app.yml</p><p>pkname 不会写死，灵活定义</p><p>也可以同时装多个包，用逗号隔开</p><p>eg：</p><pre><code>---- hosts:websever  remote_user: root  vars:    - pkname1: httpd    - pkname2: vsftpd  tasks:    - name:install pachage      yum: name={{ pkname1 }}    - name: install package      yum: name={{ pkname2 }}</code></pre><p>定义变量在playbook中，</p><pre><code>hostname.yml:---- hosts: webserver  rempte_user: root  tasks:    - name: set hostname      hostname: name= www{{http_port}}.magedu.com</code></pre><p>hosts：</p><pre><code>[webserver:vars]nodenamw=wwwdomainname=magedu.com</code></pre><p>此处的变量对webserver所有主机有效</p><pre><code>tasks:  - name: set hostname    hostname：name={{nodename}}{{http_port}}.{{domasinname}}</code></pre><p>命令行优先级高于配置文件</p><p>ansible all -m setup<br>ansible all -m setup -a ‘filter=”ansbile_fqdn”‘</p><pre><code>var.yml---- hosts:webserverrenote_use: roottasks:    - name: create a file    file: name=/data/{{ ansible_fqdn }}.log state=touch mode=600 owner=wang</code></pre><p>ansible-playbook -c var.yml</p><p>vars.yml</p><p>var1: httpd<br>var2: vsftpd</p><pre><code>testvars.yml---- hosts: webserver  remote_user: root  vars_file:    - vars.yml  tasks:    - name：install package      yum: name={{ var1 }}    - name: create file      file: name= /data/{{ var2 }}.log state=touch</code></pre><p>template.yml</p><pre><code>---- hosts: webserverremote_user: roottasks:     - name: install package    tum: name=nginx    - name: copy template    template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf    - name start service    service: name=nginx state=started enabled=yes</code></pre><p>ansible all -m shell -a ‘ss -ntpl’  #查看端口</p><p>nginx.conf中修改:</p><p>worker_processes NaN     #cpu个数的2次方</p><p>修改template.yml</p><pre><code>---- hosts: webserverremote_user: roottasks:     - name: install package    tum: name=nginx    - name: copy template    template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf    notify: start service    - name start service    service: name=nginx state=started enabled=yeshandlers:    - name: restart service      service: name=nginx state=restarted</code></pre><p>ansible all -m shell -a ‘ps aux | grep nginx’   #过滤nginx进程</p><p>hosts：也可以写成如下模式</p><p>[webserver]<br>192.168.80.134 http_port=81<br>192.168.80.135 http_port=82</p><p>ansible-playbook -e ‘http_port=99’ testtemp.yml  #修改端口</p><p>优先级：命令行&gt;playbook&gt;主机清单</p><p>ansibel all -m setup -a ‘filte=ansible_os_family’</p><p>‘filter=”<em>distribution</em>“‘</p><p>testitem.yml</p><pre><code>---- hosts: webserverremote_user: roottasks:    - name: create some files      file: name=/data/{{ item }} state=touch      when: ansible_distribution_major_version == &quot;7&quot;      with_items:        - file1        - file2        - file3    - name: install spme package      yum: name={{ item }}      with_items:        - htop        - sl        - hping3</code></pre><p>create_group.yml</p><pre><code>---- hosts: all  remote_user: root  tasks:    - name: create some groups      group: name={{ item }}      when: ansible_distribution_major_version == &quot;7&quot;      with_items:        - g1        - g2         - g3</code></pre><p>创建用户，并加入到组</p><pre><code>---- hosts: all  remote_user: root  tasks:    - name: create some groups      group: name={{ item }}      when: ansible_distribution_major_version == &quot;7&quot;      with_items:        - g1        - g2         - g3    - name:create some users      user: name={{item.name}} group={{item.group}}      with_items:        - { name: &apos;user1&apos;, group: &apos;g1&apos; }        - { name: &apos;user2&apos;, group: &apos;g2&apos; }        - { name: &apos;user3&apos;, group: &apos;g3&apos; }</code></pre><hr><p>for:</p><p>testfor.yml</p><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - 81      - 82      - 83  tasks:    - name: copy conf      template: src=for1.conf.j2 dest=/data/for1.conf</code></pre><p>创建文件：for1.conf.j2</p><pre><code>{% for port in ports %}    server{        listen {{ port }}    }    {% endfor %}</code></pre><hr><p>修改为字典模式：</p><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - listen_port:81      - listen_port:82      - listen_port:83  tasks:    - name: copy conf      template: src=for2.conf.j2 dest=/data/for1.conf   </code></pre><p>for2.conf.j2</p><pre><code>{% for port in ports %}    server{        listen {{ port.listen_port }}    }    {% endfor %}</code></pre><hr><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - web1:        port: 81        name: web1.magedu.com        rootdir: /data/website1      - web2:        port: 83        name: web2.magedu.com        rootdir: /data/website2      - web3:        port: 83        name: web3.magedu.com        rootdir: /data/website3  tasks:    - name: copy conf      template: src=for3.conf.j2 dest=/data/for1.conf </code></pre><p>for3.conf.j22</p><pre><code>{% for p in ports %}    server{        listen {{ p.port }}        servername {{ p.name }}        documentroot {{ p.rootdir }}    }    {% endfor %}</code></pre><hr><pre><code>---- hosts: all  remote_user: root  vars:    ports:      - web1:        port: 81        #name: web1.magedu.com        rootdir: /data/website1      - web2:        port: 83        name: web2.magedu.com        rootdir: /data/website2      - web3:        port: 83        #name: web3.magedu.com        rootdir: /data/website3  tasks:    - name: copy conf      template: src=for4.conf.j2 dest=/data/for4.conf</code></pre><p>for4.conf.j22</p><pre><code>{% for p in ports %}    server{        listen {{ p.port }}    {% if p.name is defined %}        servername {{ p.name }}    {% endif %}        documentroot {{ p.rootdir }}    }    {% endfor %}</code></pre><h2 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h2><p>创建roles文件夹：</p><p>mkdir roles</p><p>mkdir roles/{httpd, mysql, memcache} -pv</p><p>mkdir roles/nginx</p><p>ansible all -m shell -a ‘rpm -q nginx’</p><p>‘getent group nginx’</p><p>‘userdel -f nginx’ 删除用户，组</p><p>cd nginx</p><p>mkdir tasks templates</p><p>cd tasks</p><p>vim group.yml</p><pre><code>- name:create group  group: name=nginx gid=80</code></pre><p>vim user.yml</p><pre><code>- name: create user  user: name=nginx group=nginx system=yes shell=/sbin/nologin uid=80</code></pre><p>vim yum.yml</p><pre><code>- name: install package  yum: name=nginx</code></pre><p>vim start.yml</p><pre><code>- name: start service  service: name=nginx state=started enabled=yes</code></pre><p>vim restart.yml</p><pre><code>- name: restart service  sservice: name=nginx  state=restarted</code></pre><p>templates:</p><p>nginx.conf.j2(nginx.conf重命名为此)</p><p>vim temp.yml</p><pre><code>- name: copy conf  template: src=nginx.conf.j2 dest=/etc/ngiunx/nginx.conf</code></pre><p>vim main.yml</p><pre><code>- include: group.yml- include: user.yml- include: yum.yml- include: temp.yml- include: start.yml</code></pre><p>调用的剧本与roles同级</p><p>vim nginx_role.yml</p><pre><code>- hosts: all  remote_usr: root  roles:    - role: nginx</code></pre><p>ansibel-playbook -c nginx_role.yml</p><hr><p>httpd_roles</p><p>mkdir tasks</p><p>vim user.yml</p><pre><code>- name: create user  user: name=apache system=yes shell=/sbin/nologin</code></pre><p>vim copyfile.yml</p><pre><code>- name: copy file  file: src= dest=</code></pre><hr><p>httpd：</p><p>tasks：</p><p>vim user.yml</p><pre><code>- name: create user  user: name=apache system=yes shell=/sbin/nologin</code></pre><p>vim copyfile.yml</p><pre><code>- name: copy file  copy: src=httpd.conf dest=/data/</code></pre><p>vim main.yml</p><pre><code>- include: user.yml- include: copyfile.yml</code></pre><p>vim httpd_role.yml</p><pre><code>- hosts: all  remote_user: root  roles:    - role: httpd</code></pre><p>在一个角色中，调用另一个角色</p><p>vim some_role.yml</p><pre><code>- hosts: all  remote_user：root  roles:    - role: http    - role: nginx</code></pre><p> 一个角色引用另一个角色中的任务<br>在main.yml中添加一行</p><pre><code>- include: roles/httpd/tasks/copyfileyml</code></pre><p>此处需要注意路径的选择</p><p>ansible.cfg</p><p>当playbook失败的情况下，一个重试文件将会创建，后缀为retry，默认开启此功能</p><p>添加标签：<br>some_role.yml</p><pre><code>---- hosts: all  remote_user: root  roles:    - { role: httpd, tags:[&apos;web&apos;, &apos;httpd&apos;] }    #即属于web，也属于httpd    - { role: nginx, tags:[&apos;web&apos;, &apos;nginx&apos;] }</code></pre><p>ansible-playbook -t web some_role.yml   #只执行标签web</p><p>some_role.yml</p><pre><code>---- hosts: all  remote_user: root  roles:    - { role: httpd, tags:[&apos;web&apos;, &apos;httpd&apos;] }    #即属于web，也属于httpd    - { role: nginx, tags:[&apos;web&apos;, &apos;nginx&apos;] , when: ansible_distribution_major_version == &apos;7&apos;}    # 当版本为7的时候执行</code></pre><hr><p>mkdir app<br>cd app<br>mkdir tasks templates vars handlers files</p><p>task:</p><p>vim group.yml</p><pre><code>- name: create group  group: name=app system=yes gid=123</code></pre><p>vim user.yml</p><pre><code>- name: create user  user: name=app group=app system=yes shell=/sbin/nologin uid=1223</code></pre><p>vim yum.yml</p><pre><code>- name: isntall package  yum: name=httpd</code></pre><p>vim templ.yml</p><pre><code>- name: copy conf  template: src=httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf  notify: restart service</code></pre><hr><p>vars:<br>main.yml    </p><pre><code>username:appgroupname: app</code></pre><hr><p>handlers:<br>vim main.yml</p><pre><code>- name: restart service  service: name=httpd state=restarted</code></pre><hr><p> tasks:<br> vim start.yml</p><pre><code>- name: start service  service: name=httpd state=started enabled=yes</code></pre><p>vim copyfile.yml</p><pre><code>- name: copy config  copy: src=vhosts.conf dest=/etc/httpd/conf.d/ owner=app</code></pre><p>vim main.yml</p><pre><code>- include: group.yml- include: user.yml- include: yum.yml- include: templ.yml- include: copyfile.yml- include: start.yml</code></pre><hr><p>files:<br>touch vhosts.conf</p><hr><p>app_role.yml</p><pre><code>- hosts: all  remote_user: root  roles:    - app</code></pre><p>memcached:</p><p>yum install memcached</p><p>cat /etc/sysconfig/memcached</p><p>cp /etc/sysconfig/memcached templates/memcached.j2<br>修改：<br>CACHESIZE=”NaN“</p><p>vim tasks/yum.yml</p><pre><code>- name: install package  yum: name=memcached</code></pre><p>vim taska/start.yml</p><pre><code>- name: start service  service: name=memcached state=started enabled=yes</code></pre><p>vim /tasks/templ.yml</p><pre><code>- name: copy conf  templates: src=memcached.j2 dest=/etc/sysconfig/memcached</code></pre><p>vim tasks/main.yml</p><pre><code>- include: yum.yml- include: templ.yml- include: start.yml</code></pre><p>vim memcached_role.yml</p><pre><code>- hosts: all  remote_user: root  roles:    - memcached</code></pre><p>ansible-playbook -C memecached_role.yml</p><p>ansible-playbook memcached_role.yml</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ansible&quot;&gt;&lt;a href=&quot;#Ansible&quot; class=&quot;headerlink&quot; title=&quot;Ansible&quot;&gt;&lt;/a&gt;Ansible&lt;/h1&gt;&lt;h2 id=&quot;Ansible-基础&quot;&gt;&lt;a href=&quot;#Ansible-基础&quot; class=&quot;head
      
    
    </summary>
    
      <category term="ansible" scheme="http://www.baidu.com/categories/ansible/"/>
    
    
      <category term="ansible" scheme="http://www.baidu.com/tags/ansible/"/>
    
  </entry>
  
</feed>
